<!DOCTYPE html>
<html lang="en-US" dir="ltr">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>Vue 相关的问题 | ErHang Records</title>
    <meta name="description" content="A VitePress Site">
    <link rel="preload stylesheet" href="/erhang-records/assets/style.19066d32.css" as="style">
    <script type="module" src="/erhang-records/assets/app.96f7c658.js"></script>
    <link rel="preload" href="/erhang-records/assets/inter-roman-latin.2ed14f66.woff2" as="font" type="font/woff2" crossorigin="">
  <link rel="modulepreload" href="/erhang-records/assets/chunks/framework.2cb66d06.js">
  <link rel="modulepreload" href="/erhang-records/assets/chunks/theme.72c91053.js">
  <link rel="modulepreload" href="/erhang-records/assets/framework_vue.md.f502b4df.lean.js">
  <script id="check-dark-light">(()=>{const e=localStorage.getItem("vitepress-theme-appearance")||"",a=window.matchMedia("(prefers-color-scheme: dark)").matches;(!e||e==="auto"?a:e==="dark")&&document.documentElement.classList.add("dark")})();</script>
  </head>
  <body>
    <div id="app"><div class="Layout" data-v-b2cf3e0b><!--[--><!--]--><!--[--><span tabindex="-1" data-v-b8b11faa></span><a href="#VPContent" class="VPSkipLink visually-hidden" data-v-b8b11faa> Skip to content </a><!--]--><!----><header class="VPNav" data-v-b2cf3e0b data-v-7e5bc4a5><div class="VPNavBar has-sidebar" data-v-7e5bc4a5 data-v-7683ced7><div class="container" data-v-7683ced7><div class="title" data-v-7683ced7><div class="VPNavBarTitle has-sidebar" data-v-7683ced7 data-v-4d981103><a class="title" href="/erhang-records/" data-v-4d981103><!--[--><!--]--><!----><!--[-->ErHang Records<!--]--><!--[--><!--]--></a></div></div><div class="content" data-v-7683ced7><div class="curtain" data-v-7683ced7></div><div class="content-body" data-v-7683ced7><!--[--><!--]--><div class="VPNavBarSearch search" style="--vp-meta-key:&#39;Meta&#39;;" data-v-7683ced7><!----></div><nav aria-labelledby="main-nav-aria-label" class="VPNavBarMenu menu" data-v-7683ced7 data-v-7f418b0f><span id="main-nav-aria-label" class="visually-hidden" data-v-7f418b0f>Main Navigation</span><!--[--><!--[--><a class="VPLink link VPNavBarMenuLink" href="/erhang-records/" tabindex="0" data-v-7f418b0f data-v-5e623618 data-v-8f4dc553><!--[-->Home<!--]--><!----></a><!--]--><!--[--><a class="VPLink link VPNavBarMenuLink" href="/erhang-records/JavaScript/l1.html" tabindex="0" data-v-7f418b0f data-v-5e623618 data-v-8f4dc553><!--[-->Records<!--]--><!----></a><!--]--><!--]--></nav><!----><div class="VPNavBarAppearance appearance" data-v-7683ced7 data-v-f6a63727><button class="VPSwitch VPSwitchAppearance" type="button" role="switch" title="toggle dark mode" aria-checked="false" data-v-f6a63727 data-v-82b282f1 data-v-f3c41672><span class="check" data-v-f3c41672><span class="icon" data-v-f3c41672><!--[--><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" viewbox="0 0 24 24" class="sun" data-v-82b282f1><path d="M12,18c-3.3,0-6-2.7-6-6s2.7-6,6-6s6,2.7,6,6S15.3,18,12,18zM12,8c-2.2,0-4,1.8-4,4c0,2.2,1.8,4,4,4c2.2,0,4-1.8,4-4C16,9.8,14.2,8,12,8z"></path><path d="M12,4c-0.6,0-1-0.4-1-1V1c0-0.6,0.4-1,1-1s1,0.4,1,1v2C13,3.6,12.6,4,12,4z"></path><path d="M12,24c-0.6,0-1-0.4-1-1v-2c0-0.6,0.4-1,1-1s1,0.4,1,1v2C13,23.6,12.6,24,12,24z"></path><path d="M5.6,6.6c-0.3,0-0.5-0.1-0.7-0.3L3.5,4.9c-0.4-0.4-0.4-1,0-1.4s1-0.4,1.4,0l1.4,1.4c0.4,0.4,0.4,1,0,1.4C6.2,6.5,5.9,6.6,5.6,6.6z"></path><path d="M19.8,20.8c-0.3,0-0.5-0.1-0.7-0.3l-1.4-1.4c-0.4-0.4-0.4-1,0-1.4s1-0.4,1.4,0l1.4,1.4c0.4,0.4,0.4,1,0,1.4C20.3,20.7,20,20.8,19.8,20.8z"></path><path d="M3,13H1c-0.6,0-1-0.4-1-1s0.4-1,1-1h2c0.6,0,1,0.4,1,1S3.6,13,3,13z"></path><path d="M23,13h-2c-0.6,0-1-0.4-1-1s0.4-1,1-1h2c0.6,0,1,0.4,1,1S23.6,13,23,13z"></path><path d="M4.2,20.8c-0.3,0-0.5-0.1-0.7-0.3c-0.4-0.4-0.4-1,0-1.4l1.4-1.4c0.4-0.4,1-0.4,1.4,0s0.4,1,0,1.4l-1.4,1.4C4.7,20.7,4.5,20.8,4.2,20.8z"></path><path d="M18.4,6.6c-0.3,0-0.5-0.1-0.7-0.3c-0.4-0.4-0.4-1,0-1.4l1.4-1.4c0.4-0.4,1-0.4,1.4,0s0.4,1,0,1.4l-1.4,1.4C18.9,6.5,18.6,6.6,18.4,6.6z"></path></svg><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" viewbox="0 0 24 24" class="moon" data-v-82b282f1><path d="M12.1,22c-0.3,0-0.6,0-0.9,0c-5.5-0.5-9.5-5.4-9-10.9c0.4-4.8,4.2-8.6,9-9c0.4,0,0.8,0.2,1,0.5c0.2,0.3,0.2,0.8-0.1,1.1c-2,2.7-1.4,6.4,1.3,8.4c2.1,1.6,5,1.6,7.1,0c0.3-0.2,0.7-0.3,1.1-0.1c0.3,0.2,0.5,0.6,0.5,1c-0.2,2.7-1.5,5.1-3.6,6.8C16.6,21.2,14.4,22,12.1,22zM9.3,4.4c-2.9,1-5,3.6-5.2,6.8c-0.4,4.4,2.8,8.3,7.2,8.7c2.1,0.2,4.2-0.4,5.8-1.8c1.1-0.9,1.9-2.1,2.4-3.4c-2.5,0.9-5.3,0.5-7.5-1.1C9.2,11.4,8.1,7.7,9.3,4.4z"></path></svg><!--]--></span></span></button></div><div class="VPSocialLinks VPNavBarSocialLinks social-links" data-v-7683ced7 data-v-0394ad82 data-v-7bc22406><!--[--><a class="VPSocialLink" href="https://github.com/vuejs/vitepress" aria-label="github" target="_blank" rel="noopener" data-v-7bc22406 data-v-36371990><svg role="img" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><title>GitHub</title><path d="M12 .297c-6.63 0-12 5.373-12 12 0 5.303 3.438 9.8 8.205 11.385.6.113.82-.258.82-.577 0-.285-.01-1.04-.015-2.04-3.338.724-4.042-1.61-4.042-1.61C4.422 18.07 3.633 17.7 3.633 17.7c-1.087-.744.084-.729.084-.729 1.205.084 1.838 1.236 1.838 1.236 1.07 1.835 2.809 1.305 3.495.998.108-.776.417-1.305.76-1.605-2.665-.3-5.466-1.332-5.466-5.93 0-1.31.465-2.38 1.235-3.22-.135-.303-.54-1.523.105-3.176 0 0 1.005-.322 3.3 1.23.96-.267 1.98-.399 3-.405 1.02.006 2.04.138 3 .405 2.28-1.552 3.285-1.23 3.285-1.23.645 1.653.24 2.873.12 3.176.765.84 1.23 1.91 1.23 3.22 0 4.61-2.805 5.625-5.475 5.92.42.36.81 1.096.81 2.22 0 1.606-.015 2.896-.015 3.286 0 .315.21.69.825.57C20.565 22.092 24 17.592 24 12.297c0-6.627-5.373-12-12-12"/></svg></a><!--]--></div><div class="VPFlyout VPNavBarExtra extra" data-v-7683ced7 data-v-40855f84 data-v-764effdf><button type="button" class="button" aria-haspopup="true" aria-expanded="false" aria-label="extra navigation" data-v-764effdf><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" viewbox="0 0 24 24" class="icon" data-v-764effdf><circle cx="12" cy="12" r="2"></circle><circle cx="19" cy="12" r="2"></circle><circle cx="5" cy="12" r="2"></circle></svg></button><div class="menu" data-v-764effdf><div class="VPMenu" data-v-764effdf data-v-e7ea1737><!----><!--[--><!--[--><!----><div class="group" data-v-40855f84><div class="item appearance" data-v-40855f84><p class="label" data-v-40855f84>Appearance</p><div class="appearance-action" data-v-40855f84><button class="VPSwitch VPSwitchAppearance" type="button" role="switch" title="toggle dark mode" aria-checked="false" data-v-40855f84 data-v-82b282f1 data-v-f3c41672><span class="check" data-v-f3c41672><span class="icon" data-v-f3c41672><!--[--><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" viewbox="0 0 24 24" class="sun" data-v-82b282f1><path d="M12,18c-3.3,0-6-2.7-6-6s2.7-6,6-6s6,2.7,6,6S15.3,18,12,18zM12,8c-2.2,0-4,1.8-4,4c0,2.2,1.8,4,4,4c2.2,0,4-1.8,4-4C16,9.8,14.2,8,12,8z"></path><path d="M12,4c-0.6,0-1-0.4-1-1V1c0-0.6,0.4-1,1-1s1,0.4,1,1v2C13,3.6,12.6,4,12,4z"></path><path d="M12,24c-0.6,0-1-0.4-1-1v-2c0-0.6,0.4-1,1-1s1,0.4,1,1v2C13,23.6,12.6,24,12,24z"></path><path d="M5.6,6.6c-0.3,0-0.5-0.1-0.7-0.3L3.5,4.9c-0.4-0.4-0.4-1,0-1.4s1-0.4,1.4,0l1.4,1.4c0.4,0.4,0.4,1,0,1.4C6.2,6.5,5.9,6.6,5.6,6.6z"></path><path d="M19.8,20.8c-0.3,0-0.5-0.1-0.7-0.3l-1.4-1.4c-0.4-0.4-0.4-1,0-1.4s1-0.4,1.4,0l1.4,1.4c0.4,0.4,0.4,1,0,1.4C20.3,20.7,20,20.8,19.8,20.8z"></path><path d="M3,13H1c-0.6,0-1-0.4-1-1s0.4-1,1-1h2c0.6,0,1,0.4,1,1S3.6,13,3,13z"></path><path d="M23,13h-2c-0.6,0-1-0.4-1-1s0.4-1,1-1h2c0.6,0,1,0.4,1,1S23.6,13,23,13z"></path><path d="M4.2,20.8c-0.3,0-0.5-0.1-0.7-0.3c-0.4-0.4-0.4-1,0-1.4l1.4-1.4c0.4-0.4,1-0.4,1.4,0s0.4,1,0,1.4l-1.4,1.4C4.7,20.7,4.5,20.8,4.2,20.8z"></path><path d="M18.4,6.6c-0.3,0-0.5-0.1-0.7-0.3c-0.4-0.4-0.4-1,0-1.4l1.4-1.4c0.4-0.4,1-0.4,1.4,0s0.4,1,0,1.4l-1.4,1.4C18.9,6.5,18.6,6.6,18.4,6.6z"></path></svg><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" viewbox="0 0 24 24" class="moon" data-v-82b282f1><path d="M12.1,22c-0.3,0-0.6,0-0.9,0c-5.5-0.5-9.5-5.4-9-10.9c0.4-4.8,4.2-8.6,9-9c0.4,0,0.8,0.2,1,0.5c0.2,0.3,0.2,0.8-0.1,1.1c-2,2.7-1.4,6.4,1.3,8.4c2.1,1.6,5,1.6,7.1,0c0.3-0.2,0.7-0.3,1.1-0.1c0.3,0.2,0.5,0.6,0.5,1c-0.2,2.7-1.5,5.1-3.6,6.8C16.6,21.2,14.4,22,12.1,22zM9.3,4.4c-2.9,1-5,3.6-5.2,6.8c-0.4,4.4,2.8,8.3,7.2,8.7c2.1,0.2,4.2-0.4,5.8-1.8c1.1-0.9,1.9-2.1,2.4-3.4c-2.5,0.9-5.3,0.5-7.5-1.1C9.2,11.4,8.1,7.7,9.3,4.4z"></path></svg><!--]--></span></span></button></div></div></div><div class="group" data-v-40855f84><div class="item social-links" data-v-40855f84><div class="VPSocialLinks social-links-list" data-v-40855f84 data-v-7bc22406><!--[--><a class="VPSocialLink" href="https://github.com/vuejs/vitepress" aria-label="github" target="_blank" rel="noopener" data-v-7bc22406 data-v-36371990><svg role="img" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><title>GitHub</title><path d="M12 .297c-6.63 0-12 5.373-12 12 0 5.303 3.438 9.8 8.205 11.385.6.113.82-.258.82-.577 0-.285-.01-1.04-.015-2.04-3.338.724-4.042-1.61-4.042-1.61C4.422 18.07 3.633 17.7 3.633 17.7c-1.087-.744.084-.729.084-.729 1.205.084 1.838 1.236 1.838 1.236 1.07 1.835 2.809 1.305 3.495.998.108-.776.417-1.305.76-1.605-2.665-.3-5.466-1.332-5.466-5.93 0-1.31.465-2.38 1.235-3.22-.135-.303-.54-1.523.105-3.176 0 0 1.005-.322 3.3 1.23.96-.267 1.98-.399 3-.405 1.02.006 2.04.138 3 .405 2.28-1.552 3.285-1.23 3.285-1.23.645 1.653.24 2.873.12 3.176.765.84 1.23 1.91 1.23 3.22 0 4.61-2.805 5.625-5.475 5.92.42.36.81 1.096.81 2.22 0 1.606-.015 2.896-.015 3.286 0 .315.21.69.825.57C20.565 22.092 24 17.592 24 12.297c0-6.627-5.373-12-12-12"/></svg></a><!--]--></div></div></div><!--]--><!--]--></div></div></div><!--[--><!--]--><button type="button" class="VPNavBarHamburger hamburger" aria-label="mobile navigation" aria-expanded="false" aria-controls="VPNavScreen" data-v-7683ced7 data-v-e5dd9c1c><span class="container" data-v-e5dd9c1c><span class="top" data-v-e5dd9c1c></span><span class="middle" data-v-e5dd9c1c></span><span class="bottom" data-v-e5dd9c1c></span></span></button></div></div></div></div><!----></header><div class="VPLocalNav" data-v-b2cf3e0b data-v-9074c407><button class="menu" aria-expanded="false" aria-controls="VPSidebarNav" data-v-9074c407><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" viewbox="0 0 24 24" class="menu-icon" data-v-9074c407><path d="M17,11H3c-0.6,0-1-0.4-1-1s0.4-1,1-1h14c0.6,0,1,0.4,1,1S17.6,11,17,11z"></path><path d="M21,7H3C2.4,7,2,6.6,2,6s0.4-1,1-1h18c0.6,0,1,0.4,1,1S21.6,7,21,7z"></path><path d="M21,15H3c-0.6,0-1-0.4-1-1s0.4-1,1-1h18c0.6,0,1,0.4,1,1S21.6,15,21,15z"></path><path d="M17,19H3c-0.6,0-1-0.4-1-1s0.4-1,1-1h14c0.6,0,1,0.4,1,1S17.6,19,17,19z"></path></svg><span class="menu-text" data-v-9074c407>Menu</span></button><div class="VPLocalNavOutlineDropdown" style="--vp-vh:0px;" data-v-9074c407 data-v-687955bc><button data-v-687955bc>Return to top</button><!----></div></div><aside class="VPSidebar" data-v-b2cf3e0b data-v-af16598e><div class="curtain" data-v-af16598e></div><nav class="nav" id="VPSidebarNav" aria-labelledby="sidebar-aria-label" tabindex="-1" data-v-af16598e><span class="visually-hidden" id="sidebar-aria-label" data-v-af16598e> Sidebar Navigation </span><!--[--><!--]--><!--[--><div class="group" data-v-af16598e><section class="VPSidebarItem level-0" data-v-af16598e data-v-c4656e6d><div class="item" role="button" tabindex="0" data-v-c4656e6d><div class="indicator" data-v-c4656e6d></div><h2 class="text" data-v-c4656e6d>Examples</h2><!----></div><div class="items" data-v-c4656e6d><!--[--><div class="VPSidebarItem level-1 is-link" data-v-c4656e6d data-v-c4656e6d><div class="item" data-v-c4656e6d><div class="indicator" data-v-c4656e6d></div><a class="VPLink link link" href="/erhang-records/markdown-examples.html" data-v-c4656e6d data-v-8f4dc553><!--[--><p class="text" data-v-c4656e6d>Markdown Examples</p><!--]--><!----></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-c4656e6d data-v-c4656e6d><div class="item" data-v-c4656e6d><div class="indicator" data-v-c4656e6d></div><a class="VPLink link link" href="/erhang-records/api-examples.html" data-v-c4656e6d data-v-8f4dc553><!--[--><p class="text" data-v-c4656e6d>Runtime API Examples</p><!--]--><!----></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-c4656e6d data-v-c4656e6d><div class="item" data-v-c4656e6d><div class="indicator" data-v-c4656e6d></div><a class="VPLink link link" href="/erhang-records/study-react.html" data-v-c4656e6d data-v-8f4dc553><!--[--><p class="text" data-v-c4656e6d>React Template</p><!--]--><!----></a><!----></div><!----></div><!--]--></div></section></div><div class="group" data-v-af16598e><section class="VPSidebarItem level-0 has-active" data-v-af16598e data-v-c4656e6d><div class="item" role="button" tabindex="0" data-v-c4656e6d><div class="indicator" data-v-c4656e6d></div><h2 class="text" data-v-c4656e6d>Interview-related</h2><!----></div><div class="items" data-v-c4656e6d><!--[--><section class="VPSidebarItem level-1" data-v-c4656e6d data-v-c4656e6d><div class="item" role="button" tabindex="0" data-v-c4656e6d><div class="indicator" data-v-c4656e6d></div><h3 class="text" data-v-c4656e6d>基础篇</h3><!----></div><div class="items" data-v-c4656e6d><!--[--><div class="VPSidebarItem level-2 is-link" data-v-c4656e6d data-v-c4656e6d><div class="item" data-v-c4656e6d><div class="indicator" data-v-c4656e6d></div><a class="VPLink link link" href="/erhang-records/JavaScript/l1.html" data-v-c4656e6d data-v-8f4dc553><!--[--><p class="text" data-v-c4656e6d>模块化</p><!--]--><!----></a><!----></div><!----></div><!--]--></div></section><section class="VPSidebarItem level-1" data-v-c4656e6d data-v-c4656e6d><div class="item" role="button" tabindex="0" data-v-c4656e6d><div class="indicator" data-v-c4656e6d></div><h3 class="text" data-v-c4656e6d>浏览器相关知识</h3><!----></div><div class="items" data-v-c4656e6d><!--[--><div class="VPSidebarItem level-2 is-link" data-v-c4656e6d data-v-c4656e6d><div class="item" data-v-c4656e6d><div class="indicator" data-v-c4656e6d></div><a class="VPLink link link" href="/erhang-records/browser/l1.html" data-v-c4656e6d data-v-8f4dc553><!--[--><p class="text" data-v-c4656e6d>渲染流程</p><!--]--><!----></a><!----></div><!----></div><div class="VPSidebarItem level-2 is-link" data-v-c4656e6d data-v-c4656e6d><div class="item" data-v-c4656e6d><div class="indicator" data-v-c4656e6d></div><a class="VPLink link link" href="/erhang-records/browser/l2.html" data-v-c4656e6d data-v-8f4dc553><!--[--><p class="text" data-v-c4656e6d>渲染优化</p><!--]--><!----></a><!----></div><!----></div><!--]--></div></section><section class="VPSidebarItem level-1 has-active" data-v-c4656e6d data-v-c4656e6d><div class="item" role="button" tabindex="0" data-v-c4656e6d><div class="indicator" data-v-c4656e6d></div><h3 class="text" data-v-c4656e6d>框架篇</h3><!----></div><div class="items" data-v-c4656e6d><!--[--><div class="VPSidebarItem level-2 is-link is-active has-active" data-v-c4656e6d data-v-c4656e6d><div class="item" data-v-c4656e6d><div class="indicator" data-v-c4656e6d></div><a class="VPLink link link" href="/erhang-records/framework/vue.html" data-v-c4656e6d data-v-8f4dc553><!--[--><p class="text" data-v-c4656e6d>Vue</p><!--]--><!----></a><!----></div><!----></div><div class="VPSidebarItem level-2 is-link" data-v-c4656e6d data-v-c4656e6d><div class="item" data-v-c4656e6d><div class="indicator" data-v-c4656e6d></div><a class="VPLink link link" href="/erhang-records/framework/vue-router.html" data-v-c4656e6d data-v-8f4dc553><!--[--><p class="text" data-v-c4656e6d>Vue-Router</p><!--]--><!----></a><!----></div><!----></div><div class="VPSidebarItem level-2 is-link" data-v-c4656e6d data-v-c4656e6d><div class="item" data-v-c4656e6d><div class="indicator" data-v-c4656e6d></div><a class="VPLink link link" href="/erhang-records/framework/vuex.html" data-v-c4656e6d data-v-8f4dc553><!--[--><p class="text" data-v-c4656e6d>Vuex</p><!--]--><!----></a><!----></div><!----></div><div class="VPSidebarItem level-2 is-link" data-v-c4656e6d data-v-c4656e6d><div class="item" data-v-c4656e6d><div class="indicator" data-v-c4656e6d></div><a class="VPLink link link" href="/erhang-records/framework/vue-component.html" data-v-c4656e6d data-v-8f4dc553><!--[--><p class="text" data-v-c4656e6d>Vue 组件通信</p><!--]--><!----></a><!----></div><!----></div><div class="VPSidebarItem level-2 is-link" data-v-c4656e6d data-v-c4656e6d><div class="item" data-v-c4656e6d><div class="indicator" data-v-c4656e6d></div><a class="VPLink link link" href="/erhang-records/framework/vue-life.html" data-v-c4656e6d data-v-8f4dc553><!--[--><p class="text" data-v-c4656e6d>Vue 生命周期</p><!--]--><!----></a><!----></div><!----></div><div class="VPSidebarItem level-2 is-link" data-v-c4656e6d data-v-c4656e6d><div class="item" data-v-c4656e6d><div class="indicator" data-v-c4656e6d></div><a class="VPLink link link" href="/erhang-records/framework/vue2Source.html" data-v-c4656e6d data-v-8f4dc553><!--[--><p class="text" data-v-c4656e6d>Vue2 源码</p><!--]--><!----></a><!----></div><!----></div><div class="VPSidebarItem level-2 is-link" data-v-c4656e6d data-v-c4656e6d><div class="item" data-v-c4656e6d><div class="indicator" data-v-c4656e6d></div><a class="VPLink link link" href="/erhang-records/framework/vue3Source.html" data-v-c4656e6d data-v-8f4dc553><!--[--><p class="text" data-v-c4656e6d>Vue3 源码</p><!--]--><!----></a><!----></div><!----></div><div class="VPSidebarItem level-2 is-link" data-v-c4656e6d data-v-c4656e6d><div class="item" data-v-c4656e6d><div class="indicator" data-v-c4656e6d></div><a class="VPLink link link" href="/erhang-records/framework/react.html" data-v-c4656e6d data-v-8f4dc553><!--[--><p class="text" data-v-c4656e6d>React</p><!--]--><!----></a><!----></div><!----></div><div class="VPSidebarItem level-2 is-link" data-v-c4656e6d data-v-c4656e6d><div class="item" data-v-c4656e6d><div class="indicator" data-v-c4656e6d></div><a class="VPLink link link" href="/erhang-records/framework/react-router.html" data-v-c4656e6d data-v-8f4dc553><!--[--><p class="text" data-v-c4656e6d>React-Router</p><!--]--><!----></a><!----></div><!----></div><div class="VPSidebarItem level-2 is-link" data-v-c4656e6d data-v-c4656e6d><div class="item" data-v-c4656e6d><div class="indicator" data-v-c4656e6d></div><a class="VPLink link link" href="/erhang-records/framework/redux.html" data-v-c4656e6d data-v-8f4dc553><!--[--><p class="text" data-v-c4656e6d>Redux</p><!--]--><!----></a><!----></div><!----></div><div class="VPSidebarItem level-2 is-link" data-v-c4656e6d data-v-c4656e6d><div class="item" data-v-c4656e6d><div class="indicator" data-v-c4656e6d></div><a class="VPLink link link" href="/erhang-records/framework/koa.html" data-v-c4656e6d data-v-8f4dc553><!--[--><p class="text" data-v-c4656e6d>Koa</p><!--]--><!----></a><!----></div><!----></div><div class="VPSidebarItem level-2 is-link" data-v-c4656e6d data-v-c4656e6d><div class="item" data-v-c4656e6d><div class="indicator" data-v-c4656e6d></div><a class="VPLink link link" href="/erhang-records/framework/vite-webpack.html" data-v-c4656e6d data-v-8f4dc553><!--[--><p class="text" data-v-c4656e6d>Vite Webpack</p><!--]--><!----></a><!----></div><!----></div><!--]--></div></section><!--]--></div></section></div><div class="group" data-v-af16598e><section class="VPSidebarItem level-0" data-v-af16598e data-v-c4656e6d><div class="item" role="button" tabindex="0" data-v-c4656e6d><div class="indicator" data-v-c4656e6d></div><h2 class="text" data-v-c4656e6d>Node-Learn</h2><!----></div><div class="items" data-v-c4656e6d><!--[--><section class="VPSidebarItem level-1" data-v-c4656e6d data-v-c4656e6d><div class="item" role="button" tabindex="0" data-v-c4656e6d><div class="indicator" data-v-c4656e6d></div><h3 class="text" data-v-c4656e6d>NodeJs基础</h3><!----></div><div class="items" data-v-c4656e6d><!--[--><div class="VPSidebarItem level-2 is-link" data-v-c4656e6d data-v-c4656e6d><div class="item" data-v-c4656e6d><div class="indicator" data-v-c4656e6d></div><a class="VPLink link link" href="/erhang-records/nodejs/basic/lesson1.html" data-v-c4656e6d data-v-8f4dc553><!--[--><p class="text" data-v-c4656e6d>第一课</p><!--]--><!----></a><!----></div><!----></div><!--]--></div></section><section class="VPSidebarItem level-1" data-v-c4656e6d data-v-c4656e6d><div class="item" role="button" tabindex="0" data-v-c4656e6d><div class="indicator" data-v-c4656e6d></div><h3 class="text" data-v-c4656e6d>NodeJs进阶</h3><!----></div><div class="items" data-v-c4656e6d><!--[--><div class="VPSidebarItem level-2 is-link" data-v-c4656e6d data-v-c4656e6d><div class="item" data-v-c4656e6d><div class="indicator" data-v-c4656e6d></div><a class="VPLink link link" href="/erhang-records/nodejs/other/lesson1.html" data-v-c4656e6d data-v-8f4dc553><!--[--><p class="text" data-v-c4656e6d>第一课</p><!--]--><!----></a><!----></div><!----></div><!--]--></div></section><!--]--></div></section></div><!--]--><!--[--><!--]--></nav></aside><div class="VPContent has-sidebar" id="VPContent" data-v-b2cf3e0b data-v-a494bd1d><div class="VPDoc has-sidebar has-aside" data-v-a494bd1d data-v-c4b0d3cf><!--[--><!--]--><div class="container" data-v-c4b0d3cf><div class="aside" data-v-c4b0d3cf><div class="aside-curtain" data-v-c4b0d3cf></div><div class="aside-container" data-v-c4b0d3cf><div class="aside-content" data-v-c4b0d3cf><div class="VPDocAside" data-v-c4b0d3cf data-v-3f215769><!--[--><!--]--><!--[--><!--]--><div class="VPDocAsideOutline" data-v-3f215769 data-v-ff0f39c8><div class="content" data-v-ff0f39c8><div class="outline-marker" data-v-ff0f39c8></div><div class="outline-title" data-v-ff0f39c8>On this page</div><nav aria-labelledby="doc-outline-aria-label" data-v-ff0f39c8><span class="visually-hidden" id="doc-outline-aria-label" data-v-ff0f39c8> Table of Contents for current page </span><ul class="root" data-v-ff0f39c8 data-v-9a431c33><!--[--><!--]--></ul></nav></div></div><!--[--><!--]--><div class="spacer" data-v-3f215769></div><!--[--><!--]--><!----><!--[--><!--]--><!--[--><!--]--></div></div></div></div><div class="content" data-v-c4b0d3cf><div class="content-container" data-v-c4b0d3cf><!--[--><!--]--><!----><main class="main" data-v-c4b0d3cf><div style="position:relative;" class="vp-doc _erhang-records_framework_vue" data-v-c4b0d3cf><div><h1 id="vue-相关的问题" tabindex="-1">Vue 相关的问题 <a class="header-anchor" href="#vue-相关的问题" aria-label="Permalink to &quot;Vue 相关的问题&quot;">​</a></h1><p>前一部分是和Vue3相关的 🤔</p><h2 id="🍇vue3常见问题" tabindex="-1">🍇Vue3常见问题 <a class="header-anchor" href="#🍇vue3常见问题" aria-label="Permalink to &quot;🍇Vue3常见问题&quot;">​</a></h2><h3 id="vue2-和-vue3-的区别" tabindex="-1">Vue2 和 Vue3 的区别 <a class="header-anchor" href="#vue2-和-vue3-的区别" aria-label="Permalink to &quot;Vue2 和 Vue3 的区别&quot;">​</a></h3><ul><li><p>proxy 代替 define property 做监听</p><ul><li>更全面的拦截操作：Proxy 提供了一系列拦截操作，比如 get、set、deleteProperty、apply 等。这使得我们可以拦截更多类型的操作，而不仅限于属性的读取和修改。</li><li>动态属性拦截：使用 Proxy 可以动态地拦截属性的读取和设置，而<strong>不需要事先定义属性</strong>。这与 defineProperty 不同，后者需要在对象创建时定义属性。</li><li>简化属性访问：通过使用 Proxy，我们可以通过在代理对象上直接访问属性，而<strong>无需通过特殊的 get 和 set 方法</strong>。这使得代码更简洁、易读。</li><li>更好的性能：相比于 defineProperty，Proxy 的性能更好。这是因为 Proxy 在底层实现上更加优化，拦截操作更高效。</li></ul></li><li><p>Proxy 是 ES6 引入的新特性，不支持老版本的浏览器。</p><ul><li>在使用 Proxy 时，需要确保目标环境支持它，或者使用相应的 polyfill 进行兼容处理。</li></ul></li><li><p>Proxy 提供了更灵活和强大的对象拦截功能，可以解决 defineProperty 的一些限制，并提供了更好的性能和简化的语法。</p></li></ul><h3 id="vue3-相比较-vue2-的-diff-算法有哪些优化" tabindex="-1">Vue3 相比较 Vue2 的 diff 算法有哪些优化 <a class="header-anchor" href="#vue3-相比较-vue2-的-diff-算法有哪些优化" aria-label="Permalink to &quot;Vue3 相比较 Vue2 的 diff 算法有哪些优化&quot;">​</a></h3><p>Vue 3 在与 Vue 2 相比的 diff 算法上进行了一些优化，主要包括以下几点：</p><ul><li><p>静态节点提升（Static Node Hoisting）：</p><ul><li>Vue 3 使用了更高效的静态节点提升技术，将静态节点在编译阶段就提升为常量，避免了运行时的重复创建和比对。这样可以减少虚拟 DOM 的节点数，从而提高了渲染性能。</li><li>在 Vue 2 中，每次组件渲染时，都会生成新的虚拟 DOM 树，即使是静态节点也会重新创建。</li><li>在 Vue 3 中，编译器会将模板中的静态节点（即不会改变的节点）在编译阶段优化，并将它们提升为常量。这样在每次渲染时，静态节点不需要重新创建，减少了虚拟 DOM 的节点数，提高了渲染性能。</li></ul></li><li><p>事件侦听器缓存：</p><ul><li>Vue 3 通过事件侦听器的缓存，减少了对事件处理函数的重复创建。</li><li>在 Vue 2 中，每次渲染时都会重新创建事件侦听器，即使事件处理函数是相同的。但在 Vue 3 中，会对事件处理函数进行缓存，只有在事件处理函数发生变化时才会重新创建。这样可以减少对事件处理函数的重复创建和销毁，提高了性能。</li></ul></li><li><p>更细粒度的依赖追踪：</p><ul><li>Vue 3 使用了基于 Proxy 的响应式系统，相比 Vue 2 的 Object.defineProperty，可以实现更细粒度的依赖追踪。这样在数据变化时，只会触发实际依赖的更新，避免了不必要的更新操作，提高了性能。</li></ul></li><li><p>优化的数组更新：</p><ul><li>Vue 3 对数组的更新进行了优化，采用了类似 React 的技术，通过索引跟踪和避免遍历整个数组来更高效地处理数组的变化。</li></ul></li><li><p>Fragment 的支持：</p><ul><li>Vue 3 支持 Fragment（碎片），即允许在模板中使用多个根级别的元素，而无需包裹额外的标签。Fragment 可以减少 DOM 元素的数量，提高渲染性能。</li><li>在 Vue 2 中，模板中必须有一个根级别的元素，这可能会导致生成不必要的 DOM 元素。</li></ul></li><li><p>更好的 Tree-Shaking：</p><ul><li>Vue 3 的代码结构更利于 Tree-Shaking，可以在构建时更轻松地去除未使用的代码，从而减少最终的包体积。</li></ul></li><li><p>Composition API 的优化：</p><ul><li>Vue 3 的 Composition API 具有更好的可组合性，可以更灵活地组织和复用逻辑，提高了代码的可维护性和可读性。</li></ul></li></ul><h3 id="proxy-相比-defineproperty-如何实现更细粒度的依赖追踪" tabindex="-1">proxy 相比 defineProperty 如何实现更细粒度的依赖追踪 <a class="header-anchor" href="#proxy-相比-defineproperty-如何实现更细粒度的依赖追踪" aria-label="Permalink to &quot;proxy 相比 defineProperty 如何实现更细粒度的依赖追踪&quot;">​</a></h3><p>Proxy 相比 Vue 2 的 Object.defineProperty 可以实现更细粒度的依赖追踪，主要有以下几个原因：</p><ul><li><p>动态属性： Object.defineProperty 只能用于对对象已有的属性进行劫持，无法劫持对象新增的属性和删除的属性。而 <strong>Proxy 可以劫持对象所有的属性</strong>，包括新增的属性和删除的属性，从而可以更细粒度地进行依赖追踪。</p></li><li><p>数组变化： 在 Vue 2 中，对数组的响应式处理是通过重写数组的原型方法实现的，然后在这些方法中触发更新。但是这种方式有一定的局限性，无法捕获通过索引直接设置数组元素的变化。而 <strong>Proxy 可以直接监听数组的操作</strong>，如直接设置索引对应的元素，从而更准确地追踪数组的变化。</p></li><li><p>性能优化： Proxy 的性能通常比 Object.defineProperty 更好。在 Vue 2 中，每个响应式对象的属性都需要通过 Object.defineProperty 进行劫持，导致在大量数据变化时性能下降。而 Proxy 是<strong>通过代理整个对象来劫持操作，从而减少了对单个属性的劫持操作</strong>，提高了性能。</p></li><li><p>深层对象： Vue 2 对深层对象的响应式处理有一定的限制，需要在对象中预先定义属性并调用 Vue.set 或 this.$set 才能追踪其变化。而 <strong>Proxy 可以实现递归劫持</strong>，无论是对象的深层属性还是嵌套数组，都可以实现细粒度的依赖追踪，而无需预先定义属性。</p></li><li><p>降低内存消耗： 在 Vue 2 中，每个响应式对象需要维护一个响应式的 getter 和 setter，以及一个依赖收集的观察者列表。这些都会带来一定的内存消耗。而 <strong>Proxy 只需要一个全局的 Proxy 对象来代理整个对象，不需要为每个属性都创建 getter 和 setter</strong>，从而降低了内存消耗。</p></li></ul><p>综上所述，Proxy 相比 Object.defineProperty 具有更多优势，特别是在处理动态属性、数组变化和深层对象时，可以实现更细粒度的依赖追踪，并且性能更优，更适合用于实现 Vue 3 中的响应式系统。</p><h3 id="setup-语法糖的理解" tabindex="-1">setup 语法糖的理解 <a class="header-anchor" href="#setup-语法糖的理解" aria-label="Permalink to &quot;setup 语法糖的理解&quot;">​</a></h3><p>在 Vue 3 中，setup 是一个新的选项，它用于替代 Vue 2 中的一部分逻辑。</p><ul><li><p>setup 函数是组件的入口点，它在组件实例被创建之前被调用，并且在组件实例创建时被调用一次。</p></li><li><p>setup 函数接收两个参数：props 和 context。</p><ul><li>props： <ul><li>props 是一个响应式对象，包含了从父组件传递过来的属性。</li><li>在 setup 函数中，你可以直接使用 props 对象的属性，无需在 setup 函数中使用 this 访问。</li></ul></li><li>context： <ul><li>context 是一个包含了一些实用方法和属性的上下文对象。它包含了 attrs、slots、emit 等。你可以通过解构赋值或直接使用 context 对象来访问这些属性。</li></ul></li></ul></li><li><p>在 setup 函数中，你可以执行一些初始化逻辑，设置响应式数据，定义计算属性，监听事件，调用其他函数等等。setup 函数中返回的数据会在组件的模板中使用。</p></li><li><p>setup 函数<strong>相当于 Vue 2 中的 beforeCreate 和 created 钩子函数的组合</strong>，但是它比这两个钩子函数更加灵活，且能够访问到 props 和 context。在 setup 函数中，你可以自由地处理组件的状态和行为。</p></li><li><p>需要<strong>注意</strong>的是，setup 函数是一个普通的 JavaScript 函数，而不是 Vue 2 中的选项对象，所以在其中无法使用 this 访问组件实例，也无法使用 Vue 2 中的一些选项，比如 data、computed、methods 等。如果你需要使用这些选项，可以在 setup 函数中使用其他方式实现，比如使用 ref、reactive、computed 等 Vue 3 的 Composition API 提供的函数。</p></li></ul><p>总结起来，setup 语法糖是 Vue 3 中提供的一个更灵活、更强大的组件初始化方式，它能够让你更好地组织和管理组件的状态和行为。</p><h3 id="setup-中怎么设置组件-name" tabindex="-1">setup 中怎么设置组件 name <a class="header-anchor" href="#setup-中怎么设置组件-name" aria-label="Permalink to &quot;setup 中怎么设置组件 name&quot;">​</a></h3><p><code>unplugin-vue-define-options</code> 插件</p><div class="language-javascript"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#89DDFF;">&lt;</span><span style="color:#F07178;">script</span><span style="color:#89DDFF;"> </span><span style="color:#C792EA;">lang</span><span style="color:#89DDFF;">=</span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">ts</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;"> </span><span style="color:#C792EA;">setup</span><span style="color:#89DDFF;">&gt;</span></span>
<span class="line"><span style="color:#A6ACCD;">  defineOptions(</span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#A6ACCD;">    name: </span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">nameOption</span><span style="color:#89DDFF;">&#39;</span><span style="color:#89DDFF;">,</span></span>
<span class="line"><span style="color:#A6ACCD;">  </span><span style="color:#89DDFF;">}</span><span style="color:#A6ACCD;">);</span></span>
<span class="line"><span style="color:#89DDFF;">&lt;/</span><span style="color:#F07178;">script</span><span style="color:#89DDFF;">&gt;</span></span></code></pre></div><h3 id="reactive-和-shallow-reactive" tabindex="-1">reactive 和 shallow Reactive <a class="header-anchor" href="#reactive-和-shallow-reactive" aria-label="Permalink to &quot;reactive 和 shallow Reactive&quot;">​</a></h3><ul><li><p>reactive： reactive 函数会对整个对象进行递归响应式处理，即对象中的所有嵌套属性也会被转换成响应式对象。 当通过 reactive 创建的响应式对象的属性值发生变化时，会触发依赖该属性的相关响应式更新。</p></li><li><p>shallowReactive： shallowReactive 函数只会对对象的第一层属性进行响应式处理，而不会对嵌套的属性进行递归响应式处理。 当通过 shallowReactive 创建的响应式对象的第一层属性值发生变化时，会触发依赖该属性的相关响应式更新。但是，如果该属性的值是一个对象，而这个对象内部的属性发生变化，将不会触发更新。</p></li></ul><p>在大多数情况下，推荐使用 reactive 来创建响应式对象，因为它可以<strong>深度递归地处理嵌套对象，使整个对象及其嵌套属性都能触发响应式更新</strong>。只有在特定的情况下，需要避免深度递归处理对象时，才会使用 shallowReactive。</p><h3 id="ref-torefs-isref-使用" tabindex="-1">ref toRefs isRef 使用 <a class="header-anchor" href="#ref-torefs-isref-使用" aria-label="Permalink to &quot;ref toRefs isRef 使用&quot;">​</a></h3><p>在 Vue 3 的 Composition API 中，ref、toRefs 和 isRef 是用于处理响应式数据的函数。</p><ul><li><p>ref</p><ul><li><p>用于将普通数据转换为响应式数据，使其能够在组件中进行响应式更新。</p></li><li><p>使用 ref 函数创建的响应式数据是一个包装对象，可以通过 .value 属性来访问其原始值。</p></li><li><p>示例代码：</p><ul><li><div class="language-javascript"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#89DDFF;font-style:italic;">import</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">ref</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">}</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;font-style:italic;">from</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">vue</span><span style="color:#89DDFF;">&#39;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#C792EA;">const</span><span style="color:#A6ACCD;"> count </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">ref</span><span style="color:#A6ACCD;">(</span><span style="color:#F78C6C;">0</span><span style="color:#A6ACCD;">)</span></span>
<span class="line"><span style="color:#A6ACCD;">console</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">log</span><span style="color:#A6ACCD;">(count</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">value) </span><span style="color:#676E95;font-style:italic;">// Output: 0</span></span>
<span class="line"></span>
<span class="line"><span style="color:#A6ACCD;">count</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">value </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#F78C6C;">10</span><span style="color:#A6ACCD;"> </span><span style="color:#676E95;font-style:italic;">// This will trigger reactivity</span></span>
<span class="line"><span style="color:#A6ACCD;">console</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">log</span><span style="color:#A6ACCD;">(count</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">value) </span><span style="color:#676E95;font-style:italic;">// Output: 10</span></span></code></pre></div></li></ul></li></ul></li><li><p>toRefs</p><ul><li><p>用于将响应式对象转换为普通对象，并将每个属性都转换为 ref 包装。</p></li><li><p>使用 toRefs 后，可以通过 .value 属性来访问每个属性的原始值，使其在模板中能够正常使用响应式数据。</p></li><li><p>示例代码：</p><ul><li><div class="language-javascript"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#89DDFF;font-style:italic;">import</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">reactive</span><span style="color:#89DDFF;">,</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">toRefs</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">}</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;font-style:italic;">from</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">vue</span><span style="color:#89DDFF;">&#39;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#C792EA;">const</span><span style="color:#A6ACCD;"> state </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">reactive</span><span style="color:#A6ACCD;">(</span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#A6ACCD;">  </span><span style="color:#F07178;">name</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">John</span><span style="color:#89DDFF;">&#39;</span><span style="color:#89DDFF;">,</span></span>
<span class="line"><span style="color:#A6ACCD;">  </span><span style="color:#F07178;">age</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#F78C6C;">30</span></span>
<span class="line"><span style="color:#89DDFF;">}</span><span style="color:#A6ACCD;">)</span></span>
<span class="line"></span>
<span class="line"><span style="color:#C792EA;">const</span><span style="color:#A6ACCD;"> refs </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">toRefs</span><span style="color:#A6ACCD;">(state)</span></span>
<span class="line"></span>
<span class="line"><span style="color:#A6ACCD;">console</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">log</span><span style="color:#A6ACCD;">(refs</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">name</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">value) </span><span style="color:#676E95;font-style:italic;">// Output: &quot;John&quot;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#A6ACCD;">refs</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">name</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">value </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">Alice</span><span style="color:#89DDFF;">&#39;</span><span style="color:#A6ACCD;"> </span><span style="color:#676E95;font-style:italic;">// This will trigger reactivity</span></span>
<span class="line"><span style="color:#A6ACCD;">console</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">log</span><span style="color:#A6ACCD;">(state</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">name) </span><span style="color:#676E95;font-style:italic;">// Output: &quot;Alice&quot;</span></span></code></pre></div></li></ul></li></ul></li><li><p>isRef</p><ul><li><p>isRef 函数用于检查一个值是否是由 ref 创建的响应式数据。</p></li><li><p>如果传入的值是由 ref 创建的，则返回 true；否则返回 false。</p></li><li><p>示例代码：</p><ul><li><div class="language-javascript"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#89DDFF;font-style:italic;">import</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">ref</span><span style="color:#89DDFF;">,</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">isRef</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">}</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;font-style:italic;">from</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">vue</span><span style="color:#89DDFF;">&#39;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#C792EA;">const</span><span style="color:#A6ACCD;"> count </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">ref</span><span style="color:#A6ACCD;">(</span><span style="color:#F78C6C;">0</span><span style="color:#A6ACCD;">)</span></span>
<span class="line"><span style="color:#C792EA;">const</span><span style="color:#A6ACCD;"> name </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">John</span><span style="color:#89DDFF;">&#39;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#A6ACCD;">console</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">log</span><span style="color:#A6ACCD;">(</span><span style="color:#82AAFF;">isRef</span><span style="color:#A6ACCD;">(count)) </span><span style="color:#676E95;font-style:italic;">// Output: true</span></span>
<span class="line"><span style="color:#A6ACCD;">console</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">log</span><span style="color:#A6ACCD;">(</span><span style="color:#82AAFF;">isRef</span><span style="color:#A6ACCD;">(name)) </span><span style="color:#676E95;font-style:italic;">// Output: false</span></span></code></pre></div></li></ul></li></ul></li></ul><h3 id="readonly-isreadonly-shallowreadonly-使用" tabindex="-1">readonly isReadOnly shallowReadonly 使用 <a class="header-anchor" href="#readonly-isreadonly-shallowreadonly-使用" aria-label="Permalink to &quot;readonly isReadOnly shallowReadonly 使用&quot;">​</a></h3><p>在 Vue 3 的 Composition API 中，<code>readonly</code>、<code>isReadOnly</code> 和 <code>shallowReadonly</code> 是用于处理只读数据的函数。</p><ol><li><code>readonly</code>： <ul><li><code>readonly</code> 函数用于将普通数据转换为只读的响应式数据，使其不能在组件中进行修改。</li><li>使用 <code>readonly</code> 函数创建的只读响应式数据是一个包装对象，可以通过 <code>.value</code> 属性来访问其原始值。</li><li>示例代码：</li></ul></li></ol><div class="language-javascript"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#89DDFF;font-style:italic;">import</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">readonly</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">}</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;font-style:italic;">from</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">vue</span><span style="color:#89DDFF;">&#39;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#C792EA;">const</span><span style="color:#A6ACCD;"> data </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span><span style="color:#A6ACCD;"> </span><span style="color:#F07178;">name</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">John</span><span style="color:#89DDFF;">&#39;</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> </span><span style="color:#F07178;">age</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#F78C6C;">30</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#C792EA;">const</span><span style="color:#A6ACCD;"> readonlyData </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">readonly</span><span style="color:#A6ACCD;">(data)</span></span>
<span class="line"></span>
<span class="line"><span style="color:#A6ACCD;">console</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">log</span><span style="color:#A6ACCD;">(readonlyData</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">name) </span><span style="color:#676E95;font-style:italic;">// Output: &quot;John&quot;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#676E95;font-style:italic;">// Attempt to modify readonlyData will throw an error</span></span>
<span class="line"><span style="color:#676E95;font-style:italic;">// readonlyData.name = &#39;Alice&#39;; // This will throw an error</span></span></code></pre></div><ol start="2"><li><code>isReadOnly</code>： <ul><li><code>isReadOnly</code> 函数用于检查一个值是否是由 <code>readonly</code> 创建的只读响应式数据。</li><li>如果传入的值是由 <code>readonly</code> 创建的，则返回 <code>true</code>；否则返回 <code>false</code>。</li><li>示例代码：</li></ul></li></ol><div class="language-javascript"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#89DDFF;font-style:italic;">import</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">readonly</span><span style="color:#89DDFF;">,</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">isReadOnly</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">}</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;font-style:italic;">from</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">vue</span><span style="color:#89DDFF;">&#39;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#C792EA;">const</span><span style="color:#A6ACCD;"> data </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span><span style="color:#A6ACCD;"> </span><span style="color:#F07178;">name</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">John</span><span style="color:#89DDFF;">&#39;</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> </span><span style="color:#F07178;">age</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#F78C6C;">30</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#C792EA;">const</span><span style="color:#A6ACCD;"> readonlyData </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">readonly</span><span style="color:#A6ACCD;">(data)</span></span>
<span class="line"></span>
<span class="line"><span style="color:#A6ACCD;">console</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">log</span><span style="color:#A6ACCD;">(</span><span style="color:#82AAFF;">isReadOnly</span><span style="color:#A6ACCD;">(readonlyData)) </span><span style="color:#676E95;font-style:italic;">// Output: true</span></span>
<span class="line"><span style="color:#A6ACCD;">console</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">log</span><span style="color:#A6ACCD;">(</span><span style="color:#82AAFF;">isReadOnly</span><span style="color:#A6ACCD;">(data)) </span><span style="color:#676E95;font-style:italic;">// Output: false</span></span></code></pre></div><ol start="3"><li><code>shallowReadonly</code>： <ul><li><code>shallowReadonly</code> 函数用于将普通对象转换为只读的浅响应式对象，使对象的属性变成只读的，但不会递归将嵌套的对象属性转换为只读的。</li><li>使用 <code>shallowReadonly</code> 函数创建的只读浅响应式对象可以通过 <code>.value</code> 属性来访问其原始值。</li><li>示例代码：</li></ul></li></ol><div class="language-javascript"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#89DDFF;font-style:italic;">import</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">shallowReadonly</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">}</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;font-style:italic;">from</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">vue</span><span style="color:#89DDFF;">&#39;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#C792EA;">const</span><span style="color:#A6ACCD;"> data </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span><span style="color:#A6ACCD;"> </span><span style="color:#F07178;">name</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">John</span><span style="color:#89DDFF;">&#39;</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> </span><span style="color:#F07178;">info</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span><span style="color:#A6ACCD;"> </span><span style="color:#F07178;">age</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#F78C6C;">30</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">}</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#C792EA;">const</span><span style="color:#A6ACCD;"> shallowReadonlyData </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">shallowReadonly</span><span style="color:#A6ACCD;">(data)</span></span>
<span class="line"></span>
<span class="line"><span style="color:#A6ACCD;">console</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">log</span><span style="color:#A6ACCD;">(shallowReadonlyData</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">name) </span><span style="color:#676E95;font-style:italic;">// Output: &quot;John&quot;</span></span>
<span class="line"><span style="color:#A6ACCD;">console</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">log</span><span style="color:#A6ACCD;">(shallowReadonlyData</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">info</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">age) </span><span style="color:#676E95;font-style:italic;">// Output: 30</span></span>
<span class="line"></span>
<span class="line"><span style="color:#676E95;font-style:italic;">// Attempt to modify shallowReadonlyData will throw an error</span></span>
<span class="line"><span style="color:#676E95;font-style:italic;">// shallowReadonlyData.name = &#39;Alice&#39;; // This will throw an error</span></span>
<span class="line"><span style="color:#676E95;font-style:italic;">// shallowReadonlyData.info.age = 31; // This will NOT throw an error</span></span></code></pre></div><p>使用 <code>readonly</code>、<code>isReadOnly</code> 和 <code>shallowReadonly</code> 可以很方便地处理只读数据，并确保数据在组件中不会被修改。</p><h3 id="readonly-和-const-有什么区别" tabindex="-1">readonly 和 const 有什么区别？ <a class="header-anchor" href="#readonly-和-const-有什么区别" aria-label="Permalink to &quot;readonly 和 const 有什么区别？&quot;">​</a></h3><ul><li>const 是赋值保护，使用 const 定义的变量，该变量不能重新赋值。</li><li>但如果 const 赋值的是对象，那么对象里面的东西是可以改的。原因是 const 定义的变量不能改说的是，对象对应的那个地址不能改变</li><li>而 readonly 是属性保护，不能给属性重新赋值</li></ul><h3 id="vue3-生命周期的变化" tabindex="-1">Vue3 生命周期的变化？ <a class="header-anchor" href="#vue3-生命周期的变化" aria-label="Permalink to &quot;Vue3 生命周期的变化？&quot;">​</a></h3><p>在 Vue 3 中，由于采用了 Composition API 的设计，生命周期的使用方式发生了一些变化。传统的生命周期钩子函数被移除，取而代之的是可以在 <code>setup</code> 函数中使用特定的函数来模拟生命周期的行为。</p><ol><li><code>setup</code> 函数： <ul><li>在 Vue 3 中，组件的逻辑代码通常会写在 <code>setup</code> 函数中。</li><li><code>setup</code> 函数在组件创建过程中会被调用，用于初始化组件的状态和行为。</li><li>在 <code>setup</code> 函数中可以使用 Vue 提供的响应式函数和其他 API 来处理数据和逻辑。</li><li>示例代码：</li></ul></li></ol><div class="language-javascript"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#89DDFF;font-style:italic;">import</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">reactive</span><span style="color:#89DDFF;">,</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">onMounted</span><span style="color:#89DDFF;">,</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">onUpdated</span><span style="color:#89DDFF;">,</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">onUnmounted</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">}</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;font-style:italic;">from</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">vue</span><span style="color:#89DDFF;">&#39;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#89DDFF;font-style:italic;">export</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;font-style:italic;">default</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#A6ACCD;">  </span><span style="color:#F07178;">setup</span><span style="color:#89DDFF;">()</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#89DDFF;">    </span><span style="color:#676E95;font-style:italic;">// 声明响应式状态</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#C792EA;">const</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">state</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">=</span><span style="color:#F07178;"> </span><span style="color:#82AAFF;">reactive</span><span style="color:#F07178;">(</span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">      count</span><span style="color:#89DDFF;">:</span><span style="color:#F07178;"> </span><span style="color:#F78C6C;">0</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#89DDFF;">}</span><span style="color:#F07178;">)</span></span>
<span class="line"></span>
<span class="line"><span style="color:#89DDFF;">    </span><span style="color:#676E95;font-style:italic;">// 组件挂载后执行</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#82AAFF;">onMounted</span><span style="color:#F07178;">(</span><span style="color:#89DDFF;">()</span><span style="color:#F07178;"> </span><span style="color:#C792EA;">=&gt;</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">      </span><span style="color:#A6ACCD;">console</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">log</span><span style="color:#F07178;">(</span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">Component mounted</span><span style="color:#89DDFF;">&#39;</span><span style="color:#F07178;">)</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#89DDFF;">}</span><span style="color:#F07178;">)</span></span>
<span class="line"></span>
<span class="line"><span style="color:#89DDFF;">    </span><span style="color:#676E95;font-style:italic;">// 组件更新后执行</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#82AAFF;">onUpdated</span><span style="color:#F07178;">(</span><span style="color:#89DDFF;">()</span><span style="color:#F07178;"> </span><span style="color:#C792EA;">=&gt;</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">      </span><span style="color:#A6ACCD;">console</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">log</span><span style="color:#F07178;">(</span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">Component updated</span><span style="color:#89DDFF;">&#39;</span><span style="color:#F07178;">)</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#89DDFF;">}</span><span style="color:#F07178;">)</span></span>
<span class="line"></span>
<span class="line"><span style="color:#89DDFF;">    </span><span style="color:#676E95;font-style:italic;">// 组件卸载前执行</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#82AAFF;">onUnmounted</span><span style="color:#F07178;">(</span><span style="color:#89DDFF;">()</span><span style="color:#F07178;"> </span><span style="color:#C792EA;">=&gt;</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">      </span><span style="color:#A6ACCD;">console</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">log</span><span style="color:#F07178;">(</span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">Component unmounted</span><span style="color:#89DDFF;">&#39;</span><span style="color:#F07178;">)</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#89DDFF;">}</span><span style="color:#F07178;">)</span></span>
<span class="line"></span>
<span class="line"><span style="color:#89DDFF;">    </span><span style="color:#676E95;font-style:italic;">// 返回响应式状态和模板中需要使用的方法</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#89DDFF;font-style:italic;">return</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">      </span><span style="color:#A6ACCD;">state</span><span style="color:#89DDFF;">,</span></span>
<span class="line"><span style="color:#F07178;">      increment</span><span style="color:#89DDFF;">()</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">        </span><span style="color:#A6ACCD;">state</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">count</span><span style="color:#89DDFF;">++</span></span>
<span class="line"><span style="color:#F07178;">      </span><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span></code></pre></div><ol start="2"><li><p>生命周期模拟函数：</p><ul><li>在 <code>setup</code> 函数中，可以使用一些特定的函数来模拟传统的生命周期行为。</li><li>例如，可以使用 <code>onMounted</code>、<code>onUpdated</code> 和 <code>onUnmounted</code> 函数分别模拟组件的挂载、更新和卸载生命周期。</li><li><code>onMounted</code> 在组件挂载后执行，<code>onUpdated</code> 在组件更新后执行，<code>onUnmounted</code> 在组件卸载前执行。</li><li>示例代码见上面的 <code>setup</code> 函数示例。</li></ul></li><li><p><code>beforeCreate</code> 和 <code>created</code>：</p><ul><li>在 Vue 3 中，<code>beforeCreate</code> 和 <code>created</code> 生命周期钩子函数被移除了，取而代之的是使用 <code>setup</code> 函数来进行组件的初始化操作。</li></ul></li><li><p>其他生命周期钩子函数：</p><ul><li>在 Vue 3 中，其他传统的生命周期钩子函数（如 <code>beforeMount</code>、<code>mounted</code>、<code>beforeUpdate</code>、<code>updated</code>、<code>beforeDestroy</code> 和 <code>destroyed</code>）也被移除了。</li><li>相关的生命周期行为可以通过 <code>setup</code> 函数中的模拟函数来处理。</li></ul></li></ol><p>总的来说，Vue 3 的生命周期变化主要体现在使用 <code>setup</code> 函数来处理组件的初始化和生命周期行为，同时移除了传统的生命周期钩子函数，使组件的逻辑更加集中和灵活。</p><h3 id="组合式-api-和-选项式-api-的区别有哪些" tabindex="-1">组合式 api 和 选项式 api 的区别有哪些？ <a class="header-anchor" href="#组合式-api-和-选项式-api-的区别有哪些" aria-label="Permalink to &quot;组合式 api 和 选项式 api 的区别有哪些？&quot;">​</a></h3><p>组合式 API（Composition API）和选项式 API 是 Vue.js 中两种不同的组件编写风格和方式。它们有一些明显的区别，如下所示：</p><ul><li><p>选项式 API：</p><ol><li>传统的 Vue.js 组件编写方式采用选项式 API。</li><li>使用选项式 API，组件的选项（data、methods、computed、watch 等）都是在一个对象中声明。</li><li>在大型组件中，选项式 API 可能导致代码复杂度增加，难以维护。</li></ol></li><li><p>组合式 API（Composition API）：</p><ol><li>组合式 API 是 Vue.js 3 引入的一种新的组件编写方式。</li><li>使用组合式 API，可以通过将逻辑功能按照功能进行分组，将相关功能组织成一个独立的函数，从而使代码更加模块化、可读性更好。</li><li>组合式 API 中的函数可以在 <code>setup</code> 函数中被调用，并且可以返回数据、方法等供模板使用。</li><li>组合式 API 可以在多个组件之间共享逻辑，提高了代码的可重用性。</li></ol></li><li><p>主要区别：</p><ol><li>组合式 API 更加灵活，能够更好地组织代码，使代码更加模块化和可读性更好。</li><li>组合式 API 支持在多个组件之间共享逻辑，而选项式 API 中的逻辑复用需要通过 mixins 或高阶组件来实现，不够直观和优雅。</li><li>组合式 API 可以更好地解决 Vue 2 中 mixins 带来的一些问题，例如命名冲突、混乱的调用顺序等。</li></ol></li></ul><p>总的来说，组合式 API 是 Vue.js 3 中引入的一种更加灵活和强大的组件编写方式，它能够更好地解决 Vue 2 中选项式 API 在大型组件中的一些问题，提高了代码的可读性、可维护性和复用性。对于新的项目和组件，推荐使用组合式 API 编写。对于现有的 Vue 2 项目，也可以逐渐迁移到组合式 API 来提升代码质量和开发效率。</p><h3 id="vue3-里面的-v-model-语法实现-对比-vue2-有区别吗" tabindex="-1">Vue3 里面的 v-model 语法实现，对比 Vue2 有区别吗？ <a class="header-anchor" href="#vue3-里面的-v-model-语法实现-对比-vue2-有区别吗" aria-label="Permalink to &quot;Vue3 里面的 v-model 语法实现，对比 Vue2 有区别吗？&quot;">​</a></h3><ul><li>在 Vue 2 中，v-model 用于实现表单元素和组件之间的双向绑定，可以通过在组件中使用 <code>props</code> 属性来接收外部传入的数据，并通过在组件内部使用 <code>$emit</code> 方法来触发事件，从而实现父组件和子组件之间的数据双向绑定。</li><li>在 Vue 3 中，由于引入了组合式 API，v-model 的实现方式发生了变化。现在，v-model 被认为是一个语法糖，其实质是对组件内部的 <code>props</code> 和 <code>emit</code> 的包装，使得组件的双向绑定更加简洁和直观。</li><li>在 Vue 3 中，可以通过 <code>defineProps</code> 函数来定义组件的 <code>props</code>，通过 <code>defineEmits</code> 函数来定义组件的事件，然后在模板中使用 <code>v-model</code> 来实现双向绑定。</li></ul><p>下面是一个示例，展示了 Vue 3 中如何使用 v-model：</p><div class="language-javascript"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#676E95;font-style:italic;">// 子组件 ChildComponent.vue</span></span>
<span class="line"><span style="color:#89DDFF;">&lt;</span><span style="color:#F07178;">script</span><span style="color:#89DDFF;"> </span><span style="color:#C792EA;">setup</span><span style="color:#89DDFF;">&gt;</span></span>
<span class="line"><span style="color:#A6ACCD;">import </span><span style="color:#89DDFF;">{</span><span style="color:#A6ACCD;"> defineProps</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> defineEmits </span><span style="color:#89DDFF;">}</span><span style="color:#A6ACCD;"> from &#39;vue&#39;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#A6ACCD;">const </span><span style="color:#89DDFF;">{</span><span style="color:#A6ACCD;"> value </span><span style="color:#89DDFF;">}</span><span style="color:#A6ACCD;"> = defineProps([&#39;modelValue&#39;])</span></span>
<span class="line"><span style="color:#A6ACCD;">const emit = defineEmits()</span></span>
<span class="line"></span>
<span class="line"><span style="color:#A6ACCD;">const handleChange = (newValue) =&gt; </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#A6ACCD;">  </span><span style="color:#82AAFF;">emit</span><span style="color:#A6ACCD;">(</span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">update:modelValue</span><span style="color:#89DDFF;">&#39;</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> newValue)</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#89DDFF;">&lt;/</span><span style="color:#F07178;">script</span><span style="color:#89DDFF;">&gt;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#89DDFF;">&lt;</span><span style="color:#F07178;">template</span><span style="color:#89DDFF;">&gt;</span></span>
<span class="line"><span style="color:#A6ACCD;">  </span><span style="color:#89DDFF;">&lt;</span><span style="color:#F07178;">input</span><span style="color:#89DDFF;"> :value=&quot;value&quot; @input=&quot;handleChange($event.target.value)&quot; /&gt;</span></span>
<span class="line"><span style="color:#89DDFF;">&lt;/</span><span style="color:#F07178;">template</span><span style="color:#89DDFF;">&gt;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#676E95;font-style:italic;">// 父组件 ParentComponent.vue</span></span>
<span class="line"><span style="color:#89DDFF;">&lt;</span><span style="color:#F07178;">template</span><span style="color:#89DDFF;">&gt;</span></span>
<span class="line"><span style="color:#A6ACCD;">  </span><span style="color:#89DDFF;">&lt;</span><span style="color:#FFCB6B;">child-component</span><span style="color:#89DDFF;"> </span><span style="color:#C792EA;">v-model</span><span style="color:#89DDFF;">=</span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">message</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;"> /&gt;</span></span>
<span class="line"><span style="color:#89DDFF;">&lt;/</span><span style="color:#F07178;">template</span><span style="color:#89DDFF;">&gt;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#89DDFF;">&lt;</span><span style="color:#F07178;">script</span><span style="color:#89DDFF;">&gt;</span></span>
<span class="line"><span style="color:#A6ACCD;">import ChildComponent from &#39;./ChildComponent.vue&#39;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#A6ACCD;">export default </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#A6ACCD;">  components: </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#A6ACCD;">    ChildComponent</span></span>
<span class="line"><span style="color:#A6ACCD;">  </span><span style="color:#89DDFF;">},</span></span>
<span class="line"><span style="color:#A6ACCD;">  </span><span style="color:#82AAFF;">data</span><span style="color:#A6ACCD;">() </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#A6ACCD;">    return </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">      </span><span style="color:#FFCB6B;">message</span><span style="color:#89DDFF;">:</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">&#39;&#39;</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#A6ACCD;">  </span><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#89DDFF;">&lt;/</span><span style="color:#F07178;">script</span><span style="color:#89DDFF;">&gt;</span></span></code></pre></div><p>在上述示例中，子组件 <code>ChildComponent</code> 中使用了 <code>defineProps</code> 定义了 <code>props</code>，并使用 <code>defineEmits</code> 定义了 <code>emit</code> 方法。在模板中，使用 <code>v-model</code> 来实现父组件和子组件之间的双向绑定。当子组件的输入框内容发生变化时，会通过 <code>emit</code> 方法触发事件 <code>update:modelValue</code>，从而将新的值传递给父组件，实现数据的双向绑定。</p><p>需要注意的是，在 Vue 3 中，v-model 只是一个语法糖，其实质是基于 <code>props</code> 和 <code>emit</code> 实现的。因此，<strong>如果在子组件中需要使用 v-model，必须在组件选项中定义名为 <code>modelValue</code> 的 <code>props</code>，以及触发名为 <code>update:modelValue</code> 的事件</strong>。这样才能使 v-model 正常工作。</p><h3 id="vue-组件通信的方式有哪些" tabindex="-1">Vue 组件通信的方式有哪些？ <a class="header-anchor" href="#vue-组件通信的方式有哪些" aria-label="Permalink to &quot;Vue 组件通信的方式有哪些？&quot;">​</a></h3><p>在 Vue 3 中，组件通信的方式与 Vue 2 有一些变化，主要是由于引入了组合式 API 和更加灵活的响应式系统。以下是 Vue 3 中常见的组件通信方式：</p><ol><li><p>Props 和 Events：这是 Vue 2 和 Vue 3 中最常见的组件通信方式。父组件通过 props 将数据传递给子组件，子组件通过 $emit 方法触发事件，将数据传递回父组件。在 Vue 3 中，可以使用 <code>defineProps</code> 和 <code>defineEmits</code> 来定义组件的 props 和 events。</p></li><li><p>Provide 和 Inject：这是 Vue 2 中较少使用的一种组件通信方式，但在 Vue 3 中得到了改进和推广。通过在父组件中使用 <code>provide</code> 来提供数据，在子组件中使用 <code>inject</code> 来注入数据。这样可以实现跨层级的组件通信。</p></li><li><p><strong>Composition API</strong>（组合式 API）：Vue 3 中引入了组合式 API，允许将相关的逻辑封装在一个独立的函数中，然后在组件中使用。通过组合式 API，可以更灵活地实现组件之间的通信和共享逻辑。</p></li><li><p><strong>Teleport</strong>（传送）：Vue 3 中引入了 Teleport，允许将组件的内容渲染到指定的 DOM 元素上，从而实现在 DOM 树中的不同位置渲染组件内容，实现更灵活的组件布局和通信。</p></li><li><p>Custom Events（自定义事件）：Vue 3 中可以使用 <code>emits</code> 选项来定义组件支持的自定义事件，这样可以更明确地定义组件的通信行为。</p></li></ol><h4 id="两个版本有什么变化吗" tabindex="-1">两个版本有什么变化吗？ <a class="header-anchor" href="#两个版本有什么变化吗" aria-label="Permalink to &quot;两个版本有什么变化吗？&quot;">​</a></h4><ul><li>相比于 Vue 2，Vue 3 引入了组合式 API 和 Teleport，使得组件通信更加灵活和方便。</li><li>通过组合式 API，可以将相关的逻辑封装在独立的函数中，实现逻辑的复用和组合。</li><li>而 Teleport 则允许在 DOM 树中的不同位置渲染组件内容，从而实现更灵活的布局和通信。</li><li>此外，在 Vue 3 中使用 <code>defineProps</code> 和 <code>defineEmits</code> 来定义组件的 props 和 events，使得组件通信更加直观和易于维护。</li><li>Vue 3 提供了更加强大和灵活的组件通信方式，让开发者可以更方便地构建复杂的应用程序。</li></ul><h4 id="vue3-中父子传值-用-ts-怎么写-怎么设置默认值" tabindex="-1">Vue3 中父子传值 , 用 TS 怎么写，怎么设置默认值 <a class="header-anchor" href="#vue3-中父子传值-用-ts-怎么写-怎么设置默认值" aria-label="Permalink to &quot;Vue3 中父子传值 , 用 TS 怎么写，怎么设置默认值&quot;">​</a></h4><div class="language-javascript"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#89DDFF;font-style:italic;">export</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">interface</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">Props</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#A6ACCD;">  </span><span style="color:#F07178;">msg</span><span style="color:#89DDFF;">?:</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">string</span></span>
<span class="line"><span style="color:#A6ACCD;">  </span><span style="color:#F07178;">labels</span><span style="color:#89DDFF;">?:</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">string</span><span style="color:#A6ACCD;">[]</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#C792EA;">const</span><span style="color:#A6ACCD;"> props </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">withDefaults</span><span style="color:#A6ACCD;">(</span><span style="color:#82AAFF;">defineProps</span><span style="color:#89DDFF;">&lt;</span><span style="color:#FFCB6B;">Props</span><span style="color:#89DDFF;">&gt;</span><span style="color:#A6ACCD;">()</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#A6ACCD;">  </span><span style="color:#F07178;">msg</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">hello</span><span style="color:#89DDFF;">&#39;</span><span style="color:#89DDFF;">,</span></span>
<span class="line"><span style="color:#A6ACCD;">  </span><span style="color:#82AAFF;">labels</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">()</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">=&gt;</span><span style="color:#A6ACCD;"> [</span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">one</span><span style="color:#89DDFF;">&#39;</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">two</span><span style="color:#89DDFF;">&#39;</span><span style="color:#A6ACCD;">]</span></span>
<span class="line"><span style="color:#89DDFF;">}</span><span style="color:#A6ACCD;">)</span></span></code></pre></div><h3 id="watch-和-watcheffect-的区别" tabindex="-1">watch 和 watchEffect 的区别 <a class="header-anchor" href="#watch-和-watcheffect-的区别" aria-label="Permalink to &quot;watch 和 watchEffect 的区别&quot;">​</a></h3><p>watch 和 watchEffect 都是监听器，watchEffect 是一个副作用函数。</p><ul><li><p>watch ：既要指明监视的数据源，也要指明监视的回调。 而 watchEffect 可以自动监听数据源作为依赖。不用指明监视哪个数据，监视的回调中用到哪个数据，那就监视哪个数据。</p></li><li><p>watch 可以访问改变之前和之后的值，watchEffect 只能获取改变后的值。</p></li><li><p>watch 运行的时候不会立即执行，值改变后才会执行，而 watchEffect 运行后可立即执行。这一点可以通过 watch 的配置项 immediate 改变。</p></li><li><p>watchEffect 有点像 computed ：</p><ul><li>但 computed 注重的计算出来的值（回调函数的返回值）， 所以必须要写返回值。</li><li>而 watcheffect 注重的是过程（回调函数的函数体），所以不用写返回值。</li></ul></li><li><p>watch 与 vue2.x 中 watch 配置功能一致，但也有两个小坑</p><ul><li>监视 reactive 定义的响应式数据时，oldValue 无法正确获取，强制开启了深度监视（deep 配置失效）</li><li>监视 reactive 定义的响应式数据中某个属性时，deep 配置有效。</li></ul></li></ul><h3 id="computed-和-watch-的区别" tabindex="-1">computed 和 watch 的区别 <a class="header-anchor" href="#computed-和-watch-的区别" aria-label="Permalink to &quot;computed 和 watch 的区别&quot;">​</a></h3><h4 id="vue2-x" tabindex="-1">Vue2.x <a class="header-anchor" href="#vue2-x" aria-label="Permalink to &quot;Vue2.x&quot;">​</a></h4><p>computed：</p><ul><li>computed 属性是一种依赖收集的属性，它根据其依赖的响应式数据进行计算，并返回计算结果。</li><li>computed 属性是基于它的依赖进行缓存的，只有依赖的响应式数据发生变化时，才会重新计算。computed 属性可以被当作普通的属性来使用。</li></ul><p>watch：</p><ul><li>watch 选项允许我们观察一个特定的数据源，并在数据发生变化时执行回调函数。</li><li>它可以用于监听单个数据的变化或监听多个数据的变化。</li><li>watch 选项通常用于监听数据的变化并执行一些异步或开销较大的操作。</li></ul><h4 id="vue3-x" tabindex="-1">Vue3.x <a class="header-anchor" href="#vue3-x" aria-label="Permalink to &quot;Vue3.x&quot;">​</a></h4><p>computed：</p><ul><li>在 Vue 3 中，computed 属性的用法和 Vue 2 基本相同。</li><li>但是，Vue 3 对 computed 属性进行了一些性能优化，使得在某些情况下，computed 属性的计算速度更快。</li></ul><p>watch：</p><ul><li>Vue 3 中引入了一个新的 API，称为 watch 函数。</li><li>watch 函数提供了更灵活的监听选项，并可以使用函数式编程的方式进行处理。</li><li>它可以监听多个数据源的变化，并在数据发生变化时执行回调函数。</li><li>watch 函数还可以处理异步任务和批量更新的情况。</li></ul><h4 id="vue3-的-compute-相比较-vue2-做了哪些优化" tabindex="-1">Vue3 的 compute 相比较 Vue2 做了哪些优化 <a class="header-anchor" href="#vue3-的-compute-相比较-vue2-做了哪些优化" aria-label="Permalink to &quot;Vue3 的 compute 相比较 Vue2 做了哪些优化&quot;">​</a></h4><ul><li><p>缓存机制优化</p><ul><li>vue2 中 compute 无论依赖的值是否发生变化， 每次访问 computed 属性都会重新计算。 vue3 缓存机制进行了优化，只有当依赖发生变化的时候，才会进行重新浸酸。 否则会直接返回缓存结果。提高了性能，减少了不必要的计算。</li></ul></li><li><p>惰性求值</p><ul><li>vue3 中的 compute 采用了惰性求值策略。即只有在实际访问 computed 属性时，才会执行计算函数。这意味着在初始化阶段不会进行计算，只有当实际需要获取计算结果时才会进行计算。这样可以减少初始渲染的计算开销。</li></ul></li><li><p>Composition API 支持</p><ul><li>Vue 3 的 computed 属性与 Composition API 紧密集成。在 Vue 3 中，可以使用 computed 函数来定义 computed 属性，而不仅限于使用对象字面量的形式。这使得在组合式 API 中编写和组织 computed 逻辑更加灵活和可维护。</li></ul></li><li><p>更好的类型推导</p><ul><li>Vue 3 通过 TypeScript 的改进提供了更好的类型推导支持。在 Vue 3 中，根据依赖关系的变化，能够更准确地推导出 computed 属性的类型，并提供更好的类型检查和智能提示。</li></ul></li></ul><h3 id="组件缓存-keep-alive-怎么做的" tabindex="-1">组件缓存 keep-alive 怎么做的？ <a class="header-anchor" href="#组件缓存-keep-alive-怎么做的" aria-label="Permalink to &quot;组件缓存 keep-alive 怎么做的？&quot;">​</a></h3><p><code>&lt;keep-alive&gt;</code> 组件是 Vue 中用于组件缓存的特殊组件。它通过组合 Vue 的内部缓存机制和特殊的组件生命周期钩子来实现组件的缓存。</p><h4 id="vue2-和-vue3-中-keep-alive-的区别" tabindex="-1">Vue2 和 Vue3 中 keep-alive 的区别 <a class="header-anchor" href="#vue2-和-vue3-中-keep-alive-的区别" aria-label="Permalink to &quot;Vue2 和 Vue3 中 keep-alive 的区别&quot;">​</a></h4><p>在 Vue 2 和 Vue 3 中，<code>&lt;keep-alive&gt;</code> 的基本功能是相同的，即用于组件缓存。然而，Vue 3 中对 <code>&lt;keep-alive&gt;</code> 进行了一些优化和改进，使其更加灵活和高效。</p><h4 id="vue3-的-keep-alive-具体变化" tabindex="-1">Vue3 的 keep-alive 具体变化 <a class="header-anchor" href="#vue3-的-keep-alive-具体变化" aria-label="Permalink to &quot;Vue3 的 keep-alive 具体变化&quot;">​</a></h4><p>在 Vue 3 中，对 <code>&lt;keep-alive&gt;</code> 组件的内部实现进行了优化，主要包括以下方面：</p><ol><li><p><strong>虚拟 DOM 的 Diff 算法优化</strong>： 在 Vue 3 中，使用了更高效的虚拟 DOM 的 Diff 算法，称为 <code>Fast Diff</code>，它能够更精确地计算出组件树的变化，减少不必要的更新和重新渲染。这使得在 <code>&lt;keep-alive&gt;</code> 缓存的组件在被重新激活时，能够更快速地恢复到之前的状态，从而提高了组件缓存的性能和效率。</p></li><li><p><strong>缓存组件的实例状态</strong>： 在 Vue 3 中，缓存的组件实例会被更精确地保存状态，包括组件的数据、状态和事件监听器等。这样，在组件被缓存时，其状态可以完整地保留，当组件被重新激活时，可以直接使用之前保存的状态，而无需重新创建组件实例和重新初始化状态，从而进一步提高了组件缓存的性能。</p></li><li><p><strong>优化缓存策略</strong>： 在 Vue 3 中，对于被 <code>&lt;keep-alive&gt;</code> 缓存的组件，内部的缓存策略也得到了优化。当组件被缓存时，它的 DOM 结构不会被销毁，而只是被隐藏起来。这样，在组件被重新激活时，无需重新创建 DOM 元素，只需要将之前隐藏的 DOM 元素重新显示出来，从而减少了不必要的 DOM 操作，进一步提高了组件缓存的性能。</p></li></ol><p>总的来说，Vue 3 对 <code>&lt;keep-alive&gt;</code> 组件的内部实现进行了一系列优化措施，包括改进了虚拟 DOM 的 Diff 算法、优化了组件实例的状态保存和恢复，以及优化了缓存策略，从而提高了组件缓存的性能和效率。这些优化措施使得在使用 <code>&lt;keep-alive&gt;</code> 缓存组件时，能够更快速、高效地管理组件的状态和渲染，从而提升了整体的性能表现。</p><h3 id="什么是函数式组件-他和-react-的-hooks有什么区别" tabindex="-1">什么是函数式组件？ 他和 React 的 hooks有什么区别？ <a class="header-anchor" href="#什么是函数式组件-他和-react-的-hooks有什么区别" aria-label="Permalink to &quot;什么是函数式组件？ 他和 React 的 hooks有什么区别？&quot;">​</a></h3><p>函数式组件是一种在 Vue 中定义组件的方式，它基于函数而不是基于对象。函数式组件具有以下特点：</p><ol><li><p><strong>无状态：</strong> 函数式组件本身没有状态（data），只接收外部传入的 props，并根据这些 props 渲染 UI。它没有生命周期方法、实例属性等。</p></li><li><p><strong>无实例：</strong> 函数式组件没有 Vue 组件实例，因此不支持实例属性和实例方法。</p></li><li><p><strong>更轻量：</strong> 由于没有组件实例，函数式组件的渲染和销毁更加轻量，性能上可能会比普通组件更好。</p></li><li><p><strong>更易于测试：</strong> 由于函数式组件只依赖传入的 props，测试变得更加简单，不需要考虑组件实例的状态。</p></li><li><p><strong>适用场景：</strong> 函数式组件适用于只依赖外部 props 进行渲染的简单 UI 组件，例如展示性组件、纯函数组件等。</p></li></ol><p>与 React 的 Hook 相比，Vue 的函数式组件更注重于简化组件的定义和渲染过程，减少不必要的复杂性。React 的 Hook 则是一种更通用的方式，它允许在函数组件中添加状态、副作用等，使函数组件具备类组件的一些能力。</p><p>主要的区别包括：</p><ol><li><p><strong>状态管理：</strong> Vue 的函数式组件只接收 props，没有自己的状态，而 React 的 Hook 允许在函数组件中管理状态，如使用 <code>useState</code> 来添加本地状态。</p></li><li><p><strong>生命周期：</strong> Vue 的函数式组件没有生命周期钩子，React 的函数组件可以使用 <code>useEffect</code> 来处理组件的副作用。</p></li><li><p><strong>Hooks 的多样性：</strong> React 的 Hook 提供了一系列的钩子函数，用于处理状态、副作用、上下文等，从而可以实现更复杂的逻辑，而 Vue 的函数式组件则更专注于简单的 UI 渲染。</p></li></ol><p>总的来说，Vue 的函数式组件和 React 的 Hook 都是为了简化组件开发和管理，但它们在实现方式和功能上有一些区别。选择哪种方式取决于你的项目需求和个人喜好。</p><h3 id="vue3-对于编译做了哪些优化" tabindex="-1">Vue3 对于编译做了哪些优化 <a class="header-anchor" href="#vue3-对于编译做了哪些优化" aria-label="Permalink to &quot;Vue3 对于编译做了哪些优化&quot;">​</a></h3><p>Vue 3.0 作为 Vue.js 的一次重大升级，其编译器也进行了一些优化，主要包括以下几方面：</p><ul><li>静态树提升： Vue 3.0 通过重写编译器，实现对静态节点（即不改变的节点）进行编译优化，使用 HoistStatic 功能将静态节点移动到 render 函数外部进行缓存，从而服务端渲染和提高前端渲染的性能。</li></ul><p>P- atch Flag：在 Vue 3.0 中，编译的生成 vnode 会根据节点 patch 的标记，只对需要重新渲染的数据进行响应式更新，不需要更新的数据不会重新渲染，从而大大提高了渲染性能。</p><ul><li><p>静态属性提升：Vue3 中对不参与更新的元素，会做静态提升，只会被创建一次，在渲染时直接复用。免去了重复的创建操作，优化内存。 没做静态提升之前，未参与更新的元素也在 render 函数内部，会重复创建阶段。 做了静态提升后，未参与更新的元素，被放置在 render 函数外，每次渲染的时候只要取出即可。同时该元素会被打上静态标记值为-1，特殊标志是负整数表示永远不会用于 Diff。</p></li><li><p>事件监听缓存：默认情况下绑定事件行为会被视为动态绑定（没开启事件监听器缓存），所以每次都会去追踪它的变化。开启事件侦听器缓存后，没有了静态标记。也就是说下次 diff 算法的时候直接使用。</p></li><li><p>优化 Render function：Vue 3.0 的 compile 优化还包括：Render 函数的换行和缩进、Render 函数的条件折叠、Render 函数的常量折叠等等。</p></li></ul><p>总之，Vue 3.0 通过多方面的编译优化，进一步提高了框架的性能和效率，使得 Vue.js 更加高效和易用。</p><h3 id="vue3-中的内置组件-teleport-如何使用" tabindex="-1">Vue3 中的内置组件 Teleport 如何使用 <a class="header-anchor" href="#vue3-中的内置组件-teleport-如何使用" aria-label="Permalink to &quot;Vue3 中的内置组件 Teleport 如何使用&quot;">​</a></h3><p>在 Vue 3 中，<code>Teleport</code> 是一个内置组件，用于将组件的内容渲染到 DOM 结构中的其他位置，通常用于创建具有特定层叠顺序或父子关系的 UI。Teleport可以将组件的 DOM 插到指定的组件层，而不是默认的父组件层，可以用于在应用中创建模态框、悬浮提示框、通知框等组件。</p><p>Teleport 组件可以传递两个属性：</p><ul><li>to (必填)：指定组件需要挂载到的 DOM 节点的 ID，如果使用插槽的方式定义了目标容器也可以传入一个选择器字符串。</li><li>disabled (可选)：一个标志位指示此节点是否应该被瞬移到目标中，一般情况下，这个 props 建议设为一个响应式变量来控制 caption 是否展示。</li></ul><p><strong>虽然 DOM 插头被传送到另一个地方，但它的父组件仍然是当前组件，这一点必须牢记，否则会导致样式、交互等问题。</strong></p><ul><li><p>Teleport 组件不仅支持具体的 id/选择器，还可以为 to 属性绑定一个 Vue 组件实例</p></li><li><p>Teleport 组件是 Vue3 中新增的一个非常有用的组件，可以方便地实现一些弹出框、提示框等组件的功能，提高了开发效率。</p></li></ul><p><code>Teleport</code> 的使用方法如下：</p><div class="language-vue"><button title="Copy Code" class="copy"></button><span class="lang">vue</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#89DDFF;">&lt;</span><span style="color:#F07178;">template</span><span style="color:#89DDFF;">&gt;</span></span>
<span class="line"><span style="color:#A6ACCD;">  </span><span style="color:#89DDFF;">&lt;</span><span style="color:#F07178;">div</span><span style="color:#89DDFF;">&gt;</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#676E95;font-style:italic;">&lt;!-- 在原始位置渲染按钮 --&gt;</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#89DDFF;">&lt;</span><span style="color:#F07178;">button</span><span style="color:#89DDFF;"> </span><span style="color:#C792EA;">@click</span><span style="color:#89DDFF;">=</span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">showModal</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">&gt;</span><span style="color:#A6ACCD;">Show Modal</span><span style="color:#89DDFF;">&lt;/</span><span style="color:#F07178;">button</span><span style="color:#89DDFF;">&gt;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#676E95;font-style:italic;">&lt;!-- 使用 Teleport 渲染模态框 --&gt;</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#89DDFF;">&lt;</span><span style="color:#F07178;">teleport</span><span style="color:#89DDFF;"> </span><span style="color:#C792EA;">to</span><span style="color:#89DDFF;">=</span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">body</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">&gt;</span></span>
<span class="line"><span style="color:#A6ACCD;">      </span><span style="color:#89DDFF;">&lt;</span><span style="color:#F07178;">modal</span><span style="color:#89DDFF;"> </span><span style="color:#C792EA;">v-if</span><span style="color:#89DDFF;">=</span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">isModalVisible</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;"> </span><span style="color:#C792EA;">@close</span><span style="color:#89DDFF;">=</span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">hideModal</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;"> /&gt;</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#89DDFF;">&lt;/</span><span style="color:#F07178;">teleport</span><span style="color:#89DDFF;">&gt;</span></span>
<span class="line"><span style="color:#A6ACCD;">  </span><span style="color:#89DDFF;">&lt;/</span><span style="color:#F07178;">div</span><span style="color:#89DDFF;">&gt;</span></span>
<span class="line"><span style="color:#89DDFF;">&lt;/</span><span style="color:#F07178;">template</span><span style="color:#89DDFF;">&gt;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#89DDFF;">&lt;</span><span style="color:#F07178;">script</span><span style="color:#89DDFF;">&gt;</span></span>
<span class="line"><span style="color:#89DDFF;font-style:italic;">import</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">ref</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">}</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;font-style:italic;">from</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">vue</span><span style="color:#89DDFF;">&#39;</span><span style="color:#89DDFF;">;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#89DDFF;font-style:italic;">export</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;font-style:italic;">default</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#A6ACCD;">  </span><span style="color:#F07178;">name</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">App</span><span style="color:#89DDFF;">&#39;</span><span style="color:#89DDFF;">,</span></span>
<span class="line"><span style="color:#A6ACCD;">  </span><span style="color:#F07178;">components</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#89DDFF;">    </span><span style="color:#676E95;font-style:italic;">// 假设 Modal 是一个组件</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#F07178;">Modal</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#A6ACCD;">      </span><span style="color:#F07178;">template</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">`</span></span>
<span class="line"><span style="color:#C3E88D;">        &lt;div class=&quot;modal&quot;&gt;</span></span>
<span class="line"><span style="color:#C3E88D;">          &lt;div class=&quot;modal-content&quot;&gt;</span></span>
<span class="line"><span style="color:#C3E88D;">            &lt;button @click=&quot;$emit(&#39;close&#39;)&quot;&gt;Close&lt;/button&gt;</span></span>
<span class="line"><span style="color:#C3E88D;">            &lt;slot&gt;&lt;/slot&gt;</span></span>
<span class="line"><span style="color:#C3E88D;">          &lt;/div&gt;</span></span>
<span class="line"><span style="color:#C3E88D;">        &lt;/div&gt;</span></span>
<span class="line"><span style="color:#C3E88D;">      </span><span style="color:#89DDFF;">`</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#A6ACCD;">  </span><span style="color:#89DDFF;">},</span></span>
<span class="line"><span style="color:#A6ACCD;">  </span><span style="color:#F07178;">setup</span><span style="color:#89DDFF;">()</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#C792EA;">const</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">isModalVisible</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">=</span><span style="color:#F07178;"> </span><span style="color:#82AAFF;">ref</span><span style="color:#F07178;">(</span><span style="color:#FF9CAC;">false</span><span style="color:#F07178;">)</span><span style="color:#89DDFF;">;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#C792EA;">const</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">showModal</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">=</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">()</span><span style="color:#F07178;"> </span><span style="color:#C792EA;">=&gt;</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">      </span><span style="color:#A6ACCD;">isModalVisible</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">value</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">=</span><span style="color:#F07178;"> </span><span style="color:#FF9CAC;">true</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#89DDFF;">};</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#C792EA;">const</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">hideModal</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">=</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">()</span><span style="color:#F07178;"> </span><span style="color:#C792EA;">=&gt;</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">      </span><span style="color:#A6ACCD;">isModalVisible</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">value</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">=</span><span style="color:#F07178;"> </span><span style="color:#FF9CAC;">false</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#89DDFF;">};</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#89DDFF;font-style:italic;">return</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">      </span><span style="color:#A6ACCD;">isModalVisible</span><span style="color:#89DDFF;">,</span></span>
<span class="line"><span style="color:#F07178;">      </span><span style="color:#A6ACCD;">showModal</span><span style="color:#89DDFF;">,</span></span>
<span class="line"><span style="color:#F07178;">      </span><span style="color:#A6ACCD;">hideModal</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#89DDFF;">};</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#89DDFF;">};</span></span>
<span class="line"><span style="color:#89DDFF;">&lt;/</span><span style="color:#F07178;">script</span><span style="color:#89DDFF;">&gt;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#89DDFF;">&lt;</span><span style="color:#F07178;">style</span><span style="color:#89DDFF;">&gt;</span></span>
<span class="line"><span style="color:#89DDFF;">.</span><span style="color:#FFCB6B;">modal</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#A6ACCD;">  </span><span style="color:#B2CCD6;">position</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> fixed</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#A6ACCD;">  </span><span style="color:#B2CCD6;">top</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#F78C6C;">50%</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#A6ACCD;">  </span><span style="color:#B2CCD6;">left</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#F78C6C;">50%</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#A6ACCD;">  </span><span style="color:#B2CCD6;">transform</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">translate</span><span style="color:#89DDFF;">(</span><span style="color:#F78C6C;">-50%</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> </span><span style="color:#F78C6C;">-50%</span><span style="color:#89DDFF;">);</span></span>
<span class="line"><span style="color:#A6ACCD;">  </span><span style="color:#B2CCD6;">border</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#F78C6C;">1px</span><span style="color:#A6ACCD;"> solid </span><span style="color:#89DDFF;">#</span><span style="color:#A6ACCD;">ccc</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#A6ACCD;">  </span><span style="color:#B2CCD6;">background-color</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> white</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#A6ACCD;">  </span><span style="color:#B2CCD6;">padding</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#F78C6C;">1rem</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#89DDFF;">&lt;/</span><span style="color:#F07178;">style</span><span style="color:#89DDFF;">&gt;</span></span></code></pre></div><p>在上面的例子中，我们在页面的原始位置渲染了一个按钮，然后使用 <code>Teleport</code> 将模态框渲染到 <code>body</code> 元素下，从而实现了在不同 DOM 结构中渲染组件。注意，我们使用了一个假设的 <code>Modal</code> 组件来演示。实际上，你需要创建一个真正的模态框组件来替代。</p><p><code>Teleport</code> 的 <code>to</code> 属性指定了目标位置，可以是一个字符串选择器，也可以是一个 DOM 元素。通过将内容渲染到 <code>body</code> 或其他的 DOM 元素中，你可以实现更灵活的 UI 布局和层叠效果。</p><h3 id="vue3-相比较-vue2-做了哪些升级-他为什么比-vue2-更快" tabindex="-1">Vue3 相比较 Vue2 做了哪些升级？ 他为什么比 Vue2 更快？ <a class="header-anchor" href="#vue3-相比较-vue2-做了哪些升级-他为什么比-vue2-更快" aria-label="Permalink to &quot;Vue3 相比较 Vue2 做了哪些升级？ 他为什么比 Vue2 更快？&quot;">​</a></h3><ul><li><p>响应式系统优化：</p><ul><li>Vue3 引入了新的响应式系统，这个系统的设计让 Vue3 的渲染函数可以在编译时生成更少的代码，这也就意味着在运行时需要更少的代码来处理虚拟 DOM。</li><li>这个新系统的一个重要改进就是<strong>提供了基于 Proxy 实现的响应式机制</strong>，这种机制为开发人员提供更加高效的 API，也减少了一些运行时代码。</li></ul></li><li><p>编译优化：</p><ul><li>Vue3 的编译器对代码进行了优化，包括减少了部分注释、空白符和其他非必要字符的编译，同时也对编译后的代码进行了懒加载优化。</li><li>更快的虚拟 DOM：Vue3 对虚拟 DOM 进行了优化，使用了跟 React 类似的 Fiber 算法，这样可以更加高效地更新 DOM 节点，提高性能。</li></ul></li><li><p>Composition API：</p><ul><li>Vue3 引入Composition API，这种 API 通过提供逻辑组合和重用的方法来提升代码的可读性和重用性。</li><li>这种 API 不仅可以让 Vue3 应用更好地组织和维护业务逻辑，还可以让开发人员更加轻松地实现优化。</li></ul></li></ul><h3 id="setup-中如何获取组件的实例信息" tabindex="-1">setup 中如何获取组件的实例信息？ <a class="header-anchor" href="#setup-中如何获取组件的实例信息" aria-label="Permalink to &quot;setup 中如何获取组件的实例信息？&quot;">​</a></h3><p>可以使用 getCurrentInstance() 方法来获取组件实例。getCurrentInstance() 方法返回一个对象，该对象包含了组件实例以及其他相关信息。</p><p><code>const instance = getCurrentInstance();</code></p><p>getCurrentInstance() 方法只能在 setup 函数中使用，而不能在组件的生命周期方法（如 created、mounted 等方法）中使用。另外，需要注意的是，如果在 setup 函数返回之前访问了 instance 对象，那么它可能是 undefined ，因此我们需要对其进行处理。</p><h3 id="vue3-怎么实现的响应式" tabindex="-1">Vue3 怎么实现的响应式 <a class="header-anchor" href="#vue3-怎么实现的响应式" aria-label="Permalink to &quot;Vue3 怎么实现的响应式&quot;">​</a></h3><p>Vue 3 在实现响应式系统时，使用了代理对象和 JavaScript 的 <code>Proxy</code> 技术来达到更高效的效果。这种方式相对于 Vue 2 的 <code>Object.defineProperty</code> 实现，具有更好的性能和更强大的功能。</p><p>具体来说，Vue 3 的响应式系统通过以下几点实现了更高效的代理响应式：</p><ol><li><p><strong>Proxy 代理</strong>：**Vue 3 使用了 JavaScript 的 <code>Proxy</code> 对象来拦截对象属性的访问和修改，从而实现了对对象属性的动态监测。**这种方式相对于 Vue 2 的 <code>Object.defineProperty</code> 更加灵活，能够监听对象新增的属性、数组的索引和长度变化等。</p></li><li><p><strong>惰性代理</strong>：Vue 3 的代理是惰性的，即只有在访问属性时才会进行代理，这样可以减少不必要的代理操作，提高性能。</p></li><li><p><strong>代理代替深层递归</strong>：Vue 3 的代理机制可以深度代理嵌套对象，而不需要进行深层递归。这使得处理嵌套对象时性能更好，而且不会有 Vue 2 中的一些限制。</p></li><li><p><strong>响应式数据转换</strong>：Vue 3 在创建响应式代理对象时，会递归地将对象的属性都转换成响应式，这意味着你无需手动声明嵌套属性为响应式，系统会自动处理。</p></li><li><p><strong>运行时编译</strong>：Vue 3 在运行时编译过程中，会使用代理对象来处理模板中的数据绑定，这样不仅简化了编译器的实现，还提升了编译速度和运行时性能。</p></li></ol><p>总的来说，Vue 3 的代理响应式系统在性能和功能上都相对于 Vue 2 有了明显的提升。这使得开发者在编写组件时能够更自然地操作数据，而无需过多考虑数据的响应式处理。</p><h3 id="vue2-和-vue3的diff算法" tabindex="-1">Vue2 和 Vue3的diff算法 <a class="header-anchor" href="#vue2-和-vue3的diff算法" aria-label="Permalink to &quot;Vue2 和 Vue3的diff算法&quot;">​</a></h3><p>当我们谈论 Vue 2 和 Vue 3 的 diff 算法时，实际上是在谈论它们在处理虚拟 DOM 更新时的策略和技术。下面我将更详细地介绍这两个版本的 diff 算法。</p><p>Vue 2 的 Diff 算法：</p><ol><li><p><strong>递归遍历旧节点树</strong>：在每次数据变化时，Vue 2 会递归遍历旧的虚拟 DOM 树。这个过程是递归的，意味着它会一直向下遍历所有节点，直到找到需要更新的节点。</p></li><li><p><strong>比较新旧节点</strong>：对比新旧节点时，Vue 2 会先判断节点的类型是否相同。如果类型相同，则进一步比较节点的属性和子节点。如果属性或子节点有变化，Vue 2 会执行相应的 DOM 操作来更新节点。</p></li><li><p><strong>复用已有节点</strong>：Vue 2 的 diff 算法会尽量复用已有的节点，以减少 DOM 操作。但是，如果节点的类型不同，就会直接替换整个节点及其子节点。</p></li></ol><p>Vue 3 的 Diff 算法：</p><ol><li><p><strong>Proxy 代理</strong>：Vue 3 使用了 ES6 的 Proxy 对象来实现数据的“响应式”特性。当数据发生变化时，Proxy 可以捕获到对数据的访问，从而知道哪些地方需要更新。</p></li><li><p><strong>静态标记和 Patch Flag</strong>：在编译阶段，Vue 3 会对模板进行静态标记。这样一来，Vue 3 就知道哪些部分是静态的，哪些部分是动态的。在更新时，Vue 3 使用 Patch Flag 来标记节点的属性，从而确定需要进行的具体操作，比如只更新文本内容、只更新属性等。</p></li><li><p><strong>快速路径</strong>：如果发现两个节点是相同的（包括标签名、属性和子节点），Vue 3 将会执行一个“快速路径”更新，直接跳过深度比较子节点的过程。</p></li><li><p><strong>Fragments 和 Teleport</strong>：Vue 3 引入了 Fragments（片段）和 Teleport（传送门）的概念，它们允许你更高效地处理多节点的情况，或者在组件之间移动 DOM 元素而无需重新创建它们。</p></li></ol><p>总体来说，Vue 3 的 diff 算法相对于 Vue 2 来说更加智能和高效。Proxy 的使用使得数据变化可以被直接捕获，避免了不必要的遍历；静态标记和 Patch Flag 可以精确地知道哪些部分需要更新；快速路径减少了无谓的比较操作；新引入的概念如 Fragments 和 Teleport 也带来了更灵活的更新策略。这些优化使得 Vue 3 在性能和效率方面表现得更加出色。</p><h2 id="🍉-一些常见问题" tabindex="-1">🍉 一些常见问题 <a class="header-anchor" href="#🍉-一些常见问题" aria-label="Permalink to &quot;🍉 一些常见问题&quot;">​</a></h2><h2 id="_1-过滤器使用过吗" tabindex="-1">1. 过滤器使用过吗 <a class="header-anchor" href="#_1-过滤器使用过吗" aria-label="Permalink to &quot;1. 过滤器使用过吗&quot;">​</a></h2><p><strong>过滤器</strong>是 vue2 中的一个特性，作用是用于对文本进行格式化的作用。</p><p>过滤器只能应用在两个地方：<strong><code>双花括号插值</code><strong>和</strong><code>v-bind</code>表达式</strong>。</p><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#89DDFF;">&lt;!--</span><span style="color:#A6ACCD;">在双花括号中使用 格式：</span><span style="color:#89DDFF;">{{</span><span style="color:#A6ACCD;">值</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">|</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">过滤器的名称</span><span style="color:#89DDFF;">}}--&gt;</span></span>
<span class="line"><span style="color:#89DDFF;">&lt;</span><span style="color:#F07178;">div</span><span style="color:#89DDFF;">&gt;{{</span><span style="color:#F78C6C;">3</span><span style="color:#F07178;"> | addZero</span><span style="color:#89DDFF;">}}&lt;/</span><span style="color:#F07178;">div</span><span style="color:#89DDFF;">&gt;</span></span>
<span class="line"><span style="color:#89DDFF;">&lt;!--</span><span style="color:#A6ACCD;">在v</span><span style="color:#89DDFF;">-</span><span style="color:#A6ACCD;">bind中使用 格式：v</span><span style="color:#89DDFF;">-</span><span style="color:#FFCB6B;">bind</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;">id</span><span style="color:#89DDFF;">=</span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">值 | 过滤器的名称</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">--&gt;</span></span>
<span class="line"><span style="color:#89DDFF;">&lt;</span><span style="color:#F07178;">div</span><span style="color:#89DDFF;"> </span><span style="color:#C792EA;">v-bind</span><span style="color:#89DDFF;">:</span><span style="color:#C792EA;">id</span><span style="color:#89DDFF;">=</span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">1 | addZero</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">&gt;</span><span style="color:#A6ACCD;">11</span><span style="color:#89DDFF;">&lt;/</span><span style="color:#F07178;">div</span><span style="color:#89DDFF;">&gt;</span></span></code></pre></div><p>vue3 版本删除了过滤器，因为它和定义一个 method 没有啥本质的区别。</p><h2 id="_2-slot-插槽的使用" tabindex="-1">2. slot 插槽的使用 <a class="header-anchor" href="#_2-slot-插槽的使用" aria-label="Permalink to &quot;2. slot 插槽的使用&quot;">​</a></h2><p>插槽分为普通插槽和作用域插槽，它们可以解决不同的场景</p><p><strong>扫盲</strong></p><p>编译是发生在调用 <code>vm.$mount</code> 的时候，所以编译的顺序是先编译父组件，再编译子组件。</p><ul><li><p>首先编译父组件，在 <code>parse</code> 阶段，会执行 <code>processSlot</code> 处理 <code>slot</code></p><ul><li>当解析到标签上有 <code>slot</code> 属性的时候，会给对应的 AST 元素节点添加 <code>slotTarget</code> 属性，然后在 <code>codegen</code> 阶段，在 <code>genData</code> 中会处理 <code>slotTarget</code></li><li>会给 <code>data</code> 添加一个 <code>slot</code> 属性，并指向 <code>slotTarget</code></li></ul></li><li><p>接下来编译子组件，同样在 <code>parser</code> 阶段会执行 <code>processSlot</code> 处理函数</p><ul><li><p>当遇到 <code>slot</code> 标签的时候会给对应的 AST 元素节点添加 <code>slotName</code> 属性，然后在 <code>codegen</code> 阶段，会判断如果当前 AST 元素节点是 <code>slot</code> 标签，则执行 <code>genSlot</code> 函数</p></li><li><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#C792EA;">function</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">genSlot</span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;font-style:italic;">el</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">ASTElement</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> </span><span style="color:#A6ACCD;font-style:italic;">state</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">CodegenState</span><span style="color:#89DDFF;">):</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">string</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#C792EA;">const</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">slotName</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">=</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">el</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">slotName</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">||</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">&quot;default&quot;</span><span style="color:#89DDFF;">&#39;</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#C792EA;">const</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">children</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">=</span><span style="color:#F07178;"> </span><span style="color:#82AAFF;">genChildren</span><span style="color:#F07178;">(</span><span style="color:#A6ACCD;">el</span><span style="color:#89DDFF;">,</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">state</span><span style="color:#F07178;">)</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#C792EA;">let</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">res</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">=</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">`</span><span style="color:#C3E88D;">_t(</span><span style="color:#89DDFF;">${</span><span style="color:#A6ACCD;">slotName</span><span style="color:#89DDFF;">}${</span><span style="color:#A6ACCD;">children </span><span style="color:#89DDFF;">?</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">`</span><span style="color:#C3E88D;">,</span><span style="color:#89DDFF;">${</span><span style="color:#A6ACCD;">children</span><span style="color:#89DDFF;">}`</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&#39;&#39;}`</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#C792EA;">const</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">attrs</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">=</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">el</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">attrs</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">&amp;&amp;</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">`</span><span style="color:#C3E88D;">{</span><span style="color:#89DDFF;">${</span><span style="color:#A6ACCD;">el</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">attrs</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">map</span><span style="color:#A6ACCD;">(</span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;font-style:italic;">a</span><span style="color:#89DDFF;">)</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">=&gt;</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">`${</span><span style="color:#82AAFF;">camelize</span><span style="color:#A6ACCD;">(a</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">name)</span><span style="color:#89DDFF;">}</span><span style="color:#C3E88D;">:</span><span style="color:#89DDFF;">${</span><span style="color:#A6ACCD;">a</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">value</span><span style="color:#89DDFF;">}`</span><span style="color:#A6ACCD;">)</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">join</span><span style="color:#A6ACCD;">(</span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">,</span><span style="color:#89DDFF;">&#39;</span><span style="color:#A6ACCD;">)</span><span style="color:#89DDFF;">}</span><span style="color:#C3E88D;">}</span><span style="color:#89DDFF;">`</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#C792EA;">const</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">bind</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">=</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">el</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">attrsMap</span><span style="color:#F07178;">[</span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">v-bind</span><span style="color:#89DDFF;">&#39;</span><span style="color:#F07178;">]</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#89DDFF;font-style:italic;">if</span><span style="color:#F07178;"> ((</span><span style="color:#A6ACCD;">attrs</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">||</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">bind</span><span style="color:#F07178;">) </span><span style="color:#89DDFF;">&amp;&amp;</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">!</span><span style="color:#A6ACCD;">children</span><span style="color:#F07178;">) </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#A6ACCD;">res</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">+=</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">`</span><span style="color:#C3E88D;">,null</span><span style="color:#89DDFF;">`</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#89DDFF;font-style:italic;">if</span><span style="color:#F07178;"> (</span><span style="color:#A6ACCD;">attrs</span><span style="color:#F07178;">) </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#A6ACCD;">res</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">+=</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">`</span><span style="color:#C3E88D;">,</span><span style="color:#89DDFF;">${</span><span style="color:#A6ACCD;">attrs</span><span style="color:#89DDFF;">}`</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#89DDFF;font-style:italic;">if</span><span style="color:#F07178;"> (</span><span style="color:#A6ACCD;">bind</span><span style="color:#F07178;">) </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#A6ACCD;">res</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">+=</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">`${</span><span style="color:#A6ACCD;">attrs </span><span style="color:#89DDFF;">?</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&#39;&#39;</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">,null</span><span style="color:#89DDFF;">&#39;}</span><span style="color:#C3E88D;">,</span><span style="color:#89DDFF;">${</span><span style="color:#A6ACCD;">bind</span><span style="color:#89DDFF;">}`</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#89DDFF;font-style:italic;">return</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">res</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">+</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">)</span><span style="color:#89DDFF;">&#39;</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span></code></pre></div></li><li><p>先不考虑 <code>slot</code> 标签上有 <code>attrs</code> 以及 <code>v-bind</code> 的情况</p></li><li><p><code>slotName</code> 从 AST 元素节点对应的属性上取，默认是 <code>default</code>，而 <code>children</code> 对应的就是 <code>slot</code> 开始和闭合标签包裹的内容</p></li></ul></li><li><p>最后 render-slot 方法</p><ul><li><code>render-slot</code> 的参数 <code>name</code> 代表插槽名称 <code>slotName</code>，<code>fallback</code> 代表插槽的默认内容生成的 <code>vnode</code> 数组。</li><li>先忽略 <code>scoped-slot</code>，只看默认插槽逻辑。</li><li>如果 <code>this.$slot[name]</code> 有值，就返回它对应的 <code>vnode</code> 数组，否则返回 <code>fallback</code>。</li></ul></li></ul><h4 id="默认插槽和作用域插槽的区别" tabindex="-1">默认插槽和作用域插槽的区别 <a class="header-anchor" href="#默认插槽和作用域插槽的区别" aria-label="Permalink to &quot;默认插槽和作用域插槽的区别&quot;">​</a></h4><p>有一个很大的差别是数据作用域</p><ul><li>普通插槽是在父组件编译和渲染阶段生成 <code>vnodes</code>，所以数据的作用域是父组件实例，子组件渲染的时候直接拿到这些渲染好的 <code>vnodes</code>。</li><li>对于作用域插槽，父组件在编译和渲染阶段并不会直接生成 <code>vnodes</code>，而是在父节点 <code>vnode</code> 的 <code>data</code> 中保留一个 <code>scopedSlots</code> 对象，存储着不同名称的插槽以及它们对应的渲染函数，只有在编译和渲染子组件阶段才会执行这个渲染函数生成 <code>vnodes</code>，由于是在子组件环境执行的，所以对应的数据作用域是子组件实例。</li></ul><p>简单地说，两种插槽的目的都是让子组件 <code>slot</code> 占位符生成的内容由父组件来决定，但数据的作用域会根据它们 <code>vnodes</code> 渲染时机不同而不同。</p><h2 id="_3-为什么采用异步渲染" tabindex="-1">3. 为什么采用异步渲染？ <a class="header-anchor" href="#_3-为什么采用异步渲染" aria-label="Permalink to &quot;3. 为什么采用异步渲染？&quot;">​</a></h2><p>为了实时更新数据被。</p><ul><li>当你在 Vue 中更改响应式状态时，最终的 DOM 更新并不是同步生效的，而是由 Vue 将它们缓存在一个队列中，直到下一个“tick”才一起执行。这样是<strong>为了确保每个组件无论发生多少状态改变，都仅执行一次更新</strong>。</li><li><code>nextTick()</code> 可以在状态改变后立即使用，以等待 DOM 更新完成。你可以传递一个回调函数作为参数，或者 await 返回的 Promise。</li></ul><h3 id="nexttick-原理及作用" tabindex="-1">nextTick 原理及作用 <a class="header-anchor" href="#nexttick-原理及作用" aria-label="Permalink to &quot;nextTick 原理及作用&quot;">​</a></h3><p>其实就是为了引出<code>JavaScript</code>运行机制，进一步来讲宏任务和微任务。</p><p>JS 执行是单线程的，它是基于事件循环的。事件循环大致分为以下几个步骤：</p><ul><li>所有同步任务都在主线程上执行，形成一个执行栈（execution context stack）。</li><li>主线程之外，还存在一个&quot;任务队列&quot;（task queue）。只要异步任务有了运行结果，就在&quot;任务队列&quot;之中放置一个事件。</li><li>一旦&quot;执行栈&quot;中的所有同步任务执行完毕，系统就会读取&quot;任务队列&quot;，看看里面有哪些事件。那些对应的异步任务，于是结束等待状态，进入执行栈，开始执行。</li><li>主线程不断重复上面的第三步。</li></ul><p><strong>主线程的执行过程就是一个 tick，而所有的异步结果都是通过 “任务队列” 来调度。</strong></p><p>消息队列中存放的是一个个的任务（task）。</p><p>task 分为两大类，分别是 macro task 和 micro task，并且每个 macro task 结束后，都要清空所有的 micro task。</p><p>在浏览器环境中，常见的 macro task 有 setTimeout、MessageChannel、postMessage、setImmediate；常见的 micro task 有 MutationObsever 和 Promise.then</p><h4 id="vue2-版本的实现" tabindex="-1">Vue2 版本的实现 <a class="header-anchor" href="#vue2-版本的实现" aria-label="Permalink to &quot;Vue2 版本的实现&quot;">​</a></h4><ul><li><p><code>next-tick.js</code> 申明了 <code>microTimerFunc</code> 和 <code>macroTimerFunc</code> 2 个变量，它们分别对应的是 micro task 的函数和 macro task 的函数。</p><ul><li>对于 macro task 的实现，优先检测是否支持原生 <code>setImmediate</code>，这是一个高版本 IE 和 Edge 才支持的特性，不支持的话再去检测是否支持原生的 <code>MessageChannel</code>，如果也不支持的话就会降级为 <code>setTimeout 0</code>；</li><li>而对于 micro task 的实现，则检测浏览器是否原生支持 Promise，不支持的话直接指向 macro task 的实现。</li></ul></li><li><p><code>next-tick.js</code> 对外暴露了 2 个函数，先来看 <code>nextTick</code>，这就是执行 <code>nextTick(flushSchedulerQueue)</code> 所用到的函数。</p><ul><li>它的逻辑也很简单，把传入的回调函数 <code>cb</code> 压入 <code>callbacks</code> 数组，最后一次性地根据 <code>useMacroTask</code> 条件执行 <code>macroTimerFunc</code> 或者是 <code>microTimerFunc</code></li><li>它们都会在下一个 tick 执行 <code>flushCallbacks</code>，<code>flushCallbacks</code> 的逻辑非常简单，对 <code>callbacks</code> 遍历，然后执行相应的回调函数。</li></ul></li><li><p>使用 <code>callbacks</code> 而不是直接在 <code>nextTick</code> 中执行回调函数的原因是<strong>保证在同一个 tick 内多次执行 <code>nextTick</code>，不会开启多个异步任务，而把这些异步任务都压成一个同步任务，在下一个 tick 执行完毕</strong>。</p></li></ul><h2 id="_4-vue2-中如何监听对象或者数组某个值的变化" tabindex="-1">4. Vue2 中如何监听对象或者数组某个值的变化？ <a class="header-anchor" href="#_4-vue2-中如何监听对象或者数组某个值的变化" aria-label="Permalink to &quot;4. Vue2 中如何监听对象或者数组某个值的变化？&quot;">​</a></h2><p>在 Vue 2 中，你可以使用“侦听属性”（Watch Property）来监听对象或数组中某个值的变化。通过在组件选项中的<code>watch</code>属性中定义需要监听的属性，你可以在属性值发生变化时执行相应的操作。</p><p>如果你想监听对象或数组的某个嵌套属性的变化，你可以使用“点符号”来表示嵌套属性的路径。例如，如果你有一个对象属性 <code>user</code>，并且想监听其 <code>name</code> 属性的变化，可以这样写：</p><div class="language-javascript"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#FFCB6B;">watch</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">user.name</span><span style="color:#89DDFF;">&#39;</span><span style="color:#F07178;">: </span><span style="color:#C792EA;">function</span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;font-style:italic;">newVal</span><span style="color:#89DDFF;">,</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;font-style:italic;">oldVal</span><span style="color:#89DDFF;">)</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#A6ACCD;">console</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">log</span><span style="color:#F07178;">(</span><span style="color:#89DDFF;">`</span><span style="color:#C3E88D;">Name changed from </span><span style="color:#89DDFF;">${</span><span style="color:#A6ACCD;">oldVal</span><span style="color:#89DDFF;">}</span><span style="color:#C3E88D;"> to </span><span style="color:#89DDFF;">${</span><span style="color:#A6ACCD;">newVal</span><span style="color:#89DDFF;">}`</span><span style="color:#F07178;">)</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#89DDFF;">},</span></span>
<span class="line"><span style="color:#89DDFF;">},</span></span></code></pre></div><p>注意，在 Vue 2 中，监听属性是基于“脏检查”的方式实现的，所以在性能方面可能不如 Vue 3 中的 Composition API 中的 <code>watch</code> 更高效。如果你的应用中需要频繁监听属性的变化，你可能会考虑使用 Vue 3 来获得更好的性能和开发体验。</p><h2 id="_5-template-和-jsx-有什么区别" tabindex="-1">5. template 和 jsx 有什么区别？ <a class="header-anchor" href="#_5-template-和-jsx-有什么区别" aria-label="Permalink to &quot;5. template 和 jsx 有什么区别？&quot;">​</a></h2><p>Vue.js支持两种主要的渲染方式：基于模板的渲染（Template-based Rendering）和基于JSX的渲染（JSX-based Rendering）。这两种方式在语法和使用上有一些区别：</p><ol><li><strong>模板渲染（Template-based Rendering）</strong>： <ul><li>模板渲染是Vue.js的默认渲染方式，也是最常用的方式。</li><li>使用HTML模板来定义组件的结构和布局，模板中可以插入动态数据和表达式。</li><li>模板语法相对于普通HTML稍有不同，比如使用双大括号<code></code>来绑定数据，使用指令（Directives）如<code>v-if</code>、<code>v-for</code>来实现条件渲染和循环渲染。</li><li>模板的语法较为简洁易懂，适合开发者快速上手和维护，特别适用于视图层较为复杂的应用。</li></ul></li><li><strong>JSX渲染（JSX-based Rendering）</strong>： <ul><li>JSX是一种JavaScript的扩展语法，类似于React中使用的语法，可以在JavaScript代码中编写HTML结构。</li><li>Vue.js也支持使用JSX来渲染组件，这需要借助于Babel插件。</li><li>使用JSX可以更自然地嵌套组件、使用JavaScript表达式，并且充分发挥了JavaScript的编程能力。</li><li>JSX相对于模板更加灵活，允许开发者在一个地方编写组件的结构、数据和逻辑，但可能需要一些熟悉度。</li></ul></li></ol><p>选择使用哪种渲染方式取决于项目的需求和开发团队的偏好。模板渲染适用于大多数情况，特别是当你需要快速构建简单到中等复杂度的视图时。JSX渲染适用于那些希望更紧密地结合JavaScript逻辑和视图的开发者，或者项目需要更高程度的动态性和灵活性。</p><h2 id="_6-简单说一下-template-到-render-的过程-怎么实现-源码-compiler-的原理" tabindex="-1">6. 简单说一下 template 到 render 的过程，怎么实现？ 源码 compiler 的原理 <a class="header-anchor" href="#_6-简单说一下-template-到-render-的过程-怎么实现-源码-compiler-的原理" aria-label="Permalink to &quot;6. 简单说一下 template 到 render 的过程，怎么实现？ 源码 compiler 的原理&quot;">​</a></h2><p><code>Vue</code> 只能通过 new 关键字初始化，然后会调用 <code>this._init</code> 方法，会初始化一些配置，主要包括</p><ul><li>合并配置，初始化生命周期，初始化事件中心，初始化渲染</li><li>初始化 data、props、computed、watcher 等等</li></ul><p><code>vm.$createElement</code> 方法定义是在执行 <code>initRender</code> 方法的时候，可以看到除了 <code>vm.$createElement</code> 方法，还有一个 <code>vm._c</code> 方法，它是被模板编译成的 <code>render</code> 函数使用，而 <code>vm.$createElement</code> 是用户手写 <code>render</code> 方法使用的， 这俩个方法支持的参数相同，并且内部都调用了 <code>createElement</code> 方法</p><p>Vue 中我们是通过 <code>$mount</code> 实例方法去挂载 <code>vm</code> 的。compiler 里面包括了$mount 重新定义的具体实现。</p><ul><li>首先缓存了原型上的 <code>$mount</code> 方法，再重新定义该方法。</li><li>它对 <code>el</code> 做了限制，Vue 不能挂载在 <code>body</code>、<code>html</code> 这样的根节点上。 <ul><li>如果没有定义 <code>render</code> 方法，则会把 <code>el</code> 或者 <code>template</code> 字符串转换成 <code>render</code> 方法。</li><li>在 Vue 2.0 版本中，所有 Vue 的组件的渲染最终都需要 <code>render</code> 方法，无论我们是用单文件 .vue 方式开发组件，还是写了 <code>el</code> 或者 <code>template</code> 属性，最终都会转换成 <code>render</code> 方法，那么这个过程是 Vue 的一个“在线编译”的过程，它是调用 <code>compileToFunctions</code> 方法实现的。</li></ul></li><li>最后，调用原先原型上的 <code>$mount</code> 方法挂载。</li></ul><p>$mount 具体干啥了</p><ul><li><p><code>$mount</code> 方法支持传入 2 个参数</p><ul><li>第一个是 <code>el</code>，它表示挂载的元素，可以是字符串，也可以是 DOM 对象， <ul><li>如果是字符串在浏览器环境下会调用 <code>query</code> 方法转换成 DOM 对象的。</li></ul></li><li>第二个参数是和服务端渲染相关，在浏览器环境下我们不需要传第二个参数。</li></ul></li><li><p><code>$mount</code> 方法实际上会去调用 <code>mountComponent</code> 方法。</p><ul><li>这个方法定义在 <code>src/core/instance/lifecycle.js</code></li><li><code>mountComponent</code> 核心就是先实例化一个渲染<code>Watcher</code>，在它的回调函数中会调用 <code>updateComponent</code> 方法，在此方法中调用 <code>vm._render</code> 方法先生成虚拟 Node，最终调用 <code>vm._update</code> 更新 DOM。</li><li><code>Watcher</code> 在这里起到两个作用 <ul><li>一个是初始化的时候会执行回调函数</li><li>另一个是当 vm 实例中的监测的数据发生变化的时候执行回调函数</li></ul></li></ul></li><li><p>函数最后判断为根节点的时候设置 <code>vm._isMounted</code> 为 <code>true</code>， 表示这个实例已经挂载了，同时执行 <code>mounted</code> 钩子函数</p></li></ul><h2 id="_7-虚拟-dom-在-vue-中怎么体现的" tabindex="-1">7. 虚拟 dom 在 vue 中怎么体现的 <a class="header-anchor" href="#_7-虚拟-dom-在-vue-中怎么体现的" aria-label="Permalink to &quot;7. 虚拟 dom 在 vue 中怎么体现的&quot;">​</a></h2><p>Virtual DOM 就是用一个原生的 JS 对象去描述一个 DOM 节点，所以它比创建一个 DOM 的代价要小很多。</p><ul><li>核心定义无非就几个关键属性，标签名、数据、子节点、键值等，其它属性都是用来扩展 VNode 的灵活性以及实现一些特殊 feature 的。</li><li>Virtual DOM 除了它的数据结构的定义，映射到真实的 DOM 实际上要经历 VNode 的 create、diff、patch 等过程。那么在 Vue.js 中，VNode 的 create 是通过 <code>createElement</code> 方法创建的，具体利用 createElement 方法创建 VNode，它定义在 <code>src/core/vdom/create-element.js</code> 中。</li></ul><p>Virtual DOM 实际上是一个树状结构，每一个 VNode 可能会有若干个子节点，这些子节点应该也是 VNode 的类型。<code>_createElement</code> 接收的第 4 个参数 children 是任意类型的，因此我们需要把它们规范成 VNode 类型。</p><ul><li>规范化 <code>children</code> 后，接下来会去创建一个 VNode 的实例。</li><li>先对 <code>tag</code> 做判断 <ul><li>如果是 <code>string</code> 类型，则接着判断如果是内置的一些节点，则直接创建一个普通 VNode</li><li>如果是为已注册的组件名，则通过 <code>createComponent</code> 创建一个组件类型的 VNode</li><li>否则创建一个未知的标签的 VNode。</li></ul></li><li>如果是 <code>tag</code> 一个 <code>Component</code> 类型，则直接调用 <code>createComponent</code> 创建一个组件类型的 VNode 节点</li></ul><h2 id="_8-异步组件使用过吗-什么场景使用的" tabindex="-1">8. 异步组件使用过吗，什么场景使用的？ <a class="header-anchor" href="#_8-异步组件使用过吗-什么场景使用的" aria-label="Permalink to &quot;8. 异步组件使用过吗，什么场景使用的？&quot;">​</a></h2><p>在大型项目中，我们可能需要拆分应用为更小的块，并仅在需要时再从服务器加载相关组件。</p><div class="language-javascript"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#89DDFF;font-style:italic;">import</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">defineAsyncComponent</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">}</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;font-style:italic;">from</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">vue</span><span style="color:#89DDFF;">&#39;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#C792EA;">const</span><span style="color:#A6ACCD;"> AsyncComp </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">defineAsyncComponent</span><span style="color:#A6ACCD;">(</span><span style="color:#89DDFF;">()</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">=&gt;</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#89DDFF;font-style:italic;">return</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">new</span><span style="color:#F07178;"> </span><span style="color:#FFCB6B;">Promise</span><span style="color:#F07178;">(</span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;font-style:italic;">resolve</span><span style="color:#89DDFF;">,</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;font-style:italic;">reject</span><span style="color:#89DDFF;">)</span><span style="color:#F07178;"> </span><span style="color:#C792EA;">=&gt;</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#89DDFF;">    </span><span style="color:#676E95;font-style:italic;">// ...从服务器获取组件</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#82AAFF;">resolve</span><span style="color:#F07178;">(</span><span style="color:#676E95;font-style:italic;">/* 获取到的组件 */</span><span style="color:#F07178;">)</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#89DDFF;">}</span><span style="color:#F07178;">)</span></span>
<span class="line"><span style="color:#89DDFF;">}</span><span style="color:#A6ACCD;">)</span></span>
<span class="line"><span style="color:#676E95;font-style:italic;">// ... 像使用其他一般组件一样使用 `AsyncComp`</span></span></code></pre></div><p>仅在页面需要它渲染时才会调用加载内部实际组件的函数。它会将接收到的 props 和插槽传给内部组件，所以你可以使用这个异步的包装组件无缝地替换原始组件，同时实现延迟加载。</p><h2 id="_9-vue-挂载过程中执行了哪些操作" tabindex="-1">9. Vue 挂载过程中执行了哪些操作 <a class="header-anchor" href="#_9-vue-挂载过程中执行了哪些操作" aria-label="Permalink to &quot;9. Vue 挂载过程中执行了哪些操作&quot;">​</a></h2><p>Vue 挂载（Mount）过程是指将Vue实例与DOM元素建立联系，使Vue实例能够控制和操作对应的DOM元素。在Vue实例挂载到DOM时，会依次执行以下操作：</p><ol><li><p><strong>实例化Vue对象：</strong> 首先，创建一个Vue实例，这个实例包含了组件的选项、数据、计算属性、方法等。</p></li><li><p><strong>初始化生命周期钩子函数：</strong> 在实例化过程中，Vue会初始化一系列生命周期钩子函数，如<code>beforeCreate</code>、<code>created</code>、<code>beforeMount</code>等。</p></li><li><p><strong>编译模板：</strong> 如果Vue实例的<code>template</code>选项存在，Vue会将模板编译成渲染函数。</p></li><li><p><strong>挂载DOM：</strong> 当Vue实例准备就绪时，它会通过<code>$mount</code>方法将自身挂载到一个DOM元素上。如果你在实例化时没有提供<code>el</code>选项，就需要手动调用<code>$mount</code>方法进行挂载。</p></li><li><p><strong>执行<code>beforeMount</code>钩子函数：</strong> 在挂载之前，会执行<code>beforeMount</code>钩子函数，允许你在DOM挂载之前进行一些操作。</p></li><li><p><strong>创建Vue组件的VNode：</strong> Vue会根据模板或渲染函数，生成组件的VNode（虚拟DOM节点）。</p></li><li><p><strong>将VNode渲染为真实DOM：</strong> Vue会将组件的VNode渲染为真实的DOM节点，并将其插入到挂载的DOM元素中。</p></li><li><p><strong>执行<code>mounted</code>钩子函数：</strong> 在挂载完成后，会执行<code>mounted</code>钩子函数，允许你在DOM挂载之后进行一些操作，比如与服务器交互、设置定时器等。</p></li></ol><p>总之，Vue的挂载过程主要包括实例化、生命周期钩子函数的初始化、模板编译、DOM挂载、钩子函数的执行等步骤，最终实现了将Vue实例与DOM元素关联起来，使其能够实时响应数据变化并更新视图。</p><h2 id="_10-vue-组件-name-属性的作用" tabindex="-1">10. Vue 组件 name 属性的作用 <a class="header-anchor" href="#_10-vue-组件-name-属性的作用" aria-label="Permalink to &quot;10. Vue 组件 name 属性的作用&quot;">​</a></h2><p><code>name</code>属性的作用包括：</p><ol><li><strong>在开发工具中显示友好的警告和错误信息：</strong> 当Vue组件在开发过程中出现警告或错误时，Vue会使用<code>name</code>属性来提供更具描述性的警告和错误信息。这可以帮助开发者快速定位问题并进行修复。</li><li><strong>方便调试：</strong> 当项目变得复杂时，不同的组件可能会相互嵌套，使用<code>name</code>属性可以使开发者更容易识别每个组件在开发工具中的名称，从而更方便地进行调试。</li><li><strong>优化组件树：</strong> 在一些情况下，Vue会根据组件的<code>name</code>属性来优化组件树的更新性能。这涉及到Vue的内部优化策略，它可以根据<code>name</code>属性的变化来判断组件是否需要重新渲染。</li></ol><h2 id="_11-怎么在组件中监听路由参数的变化" tabindex="-1">11. 怎么在组件中监听路由参数的变化？ <a class="header-anchor" href="#_11-怎么在组件中监听路由参数的变化" aria-label="Permalink to &quot;11. 怎么在组件中监听路由参数的变化？&quot;">​</a></h2><p>在Vue中，你可以使用Vue Router提供的<code>$route</code>对象来监听路由参数的变化。<code>$route</code>对象包含了当前路由的信息，包括路由路径、参数、查询字符串等。你可以通过<code>$watch</code>或使用Vue的生命周期钩子函数来实现监听路由参数的变化。</p><p>以下是在Vue组件中监听路由参数变化的两种常见方式：</p><ol><li><p><strong>使用 <code>$watch</code>：</strong> 在组件的<code>created</code>生命周期钩子函数中，使用<code>$watch</code>来监听<code>$route</code>对象的变化。通过监视路由参数对象的变化，你可以在参数发生变化时执行相应的操作。</p><div class="language-vue"><button title="Copy Code" class="copy"></button><span class="lang">vue</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#89DDFF;">&lt;</span><span style="color:#F07178;">template</span><span style="color:#89DDFF;">&gt;</span></span>
<span class="line"><span style="color:#A6ACCD;">  </span><span style="color:#89DDFF;">&lt;</span><span style="color:#F07178;">div</span><span style="color:#89DDFF;">&gt;</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#676E95;font-style:italic;">&lt;!-- 组件内容 --&gt;</span></span>
<span class="line"><span style="color:#A6ACCD;">  </span><span style="color:#89DDFF;">&lt;/</span><span style="color:#F07178;">div</span><span style="color:#89DDFF;">&gt;</span></span>
<span class="line"><span style="color:#89DDFF;">&lt;/</span><span style="color:#F07178;">template</span><span style="color:#89DDFF;">&gt;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#89DDFF;">&lt;</span><span style="color:#F07178;">script</span><span style="color:#89DDFF;">&gt;</span></span>
<span class="line"><span style="color:#89DDFF;font-style:italic;">export</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;font-style:italic;">default</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#A6ACCD;">  </span><span style="color:#F07178;">name</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">MyComponent</span><span style="color:#89DDFF;">&#39;</span><span style="color:#89DDFF;">,</span></span>
<span class="line"><span style="color:#A6ACCD;">  </span><span style="color:#F07178;">created</span><span style="color:#89DDFF;">()</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#89DDFF;">this.</span><span style="color:#82AAFF;">$watch</span><span style="color:#F07178;">(</span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">$route</span><span style="color:#89DDFF;">&#39;</span><span style="color:#89DDFF;">,</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;font-style:italic;">to</span><span style="color:#89DDFF;">,</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;font-style:italic;">from</span><span style="color:#89DDFF;">)</span><span style="color:#F07178;"> </span><span style="color:#C792EA;">=&gt;</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#89DDFF;">      </span><span style="color:#676E95;font-style:italic;">// to 和 from 是 $route 对象，你可以在这里处理参数变化的逻辑</span></span>
<span class="line"><span style="color:#F07178;">      </span><span style="color:#A6ACCD;">console</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">log</span><span style="color:#F07178;">(</span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">路由参数变化:</span><span style="color:#89DDFF;">&#39;</span><span style="color:#89DDFF;">,</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">to</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">params</span><span style="color:#89DDFF;">,</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">from</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">params</span><span style="color:#F07178;">)</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#89DDFF;">}</span><span style="color:#F07178;">)</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#89DDFF;">&lt;/</span><span style="color:#F07178;">script</span><span style="color:#89DDFF;">&gt;</span></span></code></pre></div></li><li><p><strong>使用路由参数的钩子函数：</strong> Vue Router允许你在路由配置中定义组件级别的路由守卫钩子函数，如<code>beforeRouteUpdate</code>，用于在路由参数发生变化时触发相应的操作。</p><div class="language-vue"><button title="Copy Code" class="copy"></button><span class="lang">vue</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#89DDFF;">&lt;</span><span style="color:#F07178;">template</span><span style="color:#89DDFF;">&gt;</span></span>
<span class="line"><span style="color:#A6ACCD;">  </span><span style="color:#89DDFF;">&lt;</span><span style="color:#F07178;">div</span><span style="color:#89DDFF;">&gt;</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#676E95;font-style:italic;">&lt;!-- 组件内容 --&gt;</span></span>
<span class="line"><span style="color:#A6ACCD;">  </span><span style="color:#89DDFF;">&lt;/</span><span style="color:#F07178;">div</span><span style="color:#89DDFF;">&gt;</span></span>
<span class="line"><span style="color:#89DDFF;">&lt;/</span><span style="color:#F07178;">template</span><span style="color:#89DDFF;">&gt;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#89DDFF;">&lt;</span><span style="color:#F07178;">script</span><span style="color:#89DDFF;">&gt;</span></span>
<span class="line"><span style="color:#89DDFF;font-style:italic;">export</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;font-style:italic;">default</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#A6ACCD;">  </span><span style="color:#F07178;">name</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">MyComponent</span><span style="color:#89DDFF;">&#39;</span><span style="color:#89DDFF;">,</span></span>
<span class="line"><span style="color:#A6ACCD;">  </span><span style="color:#F07178;">beforeRouteUpdate</span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;font-style:italic;">to</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> </span><span style="color:#A6ACCD;font-style:italic;">from</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> </span><span style="color:#A6ACCD;font-style:italic;">next</span><span style="color:#89DDFF;">)</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#89DDFF;">    </span><span style="color:#676E95;font-style:italic;">// to 和 from 是 $route 对象，你可以在这里处理参数变化的逻辑</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#A6ACCD;">console</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">log</span><span style="color:#F07178;">(</span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">路由参数变化:</span><span style="color:#89DDFF;">&#39;</span><span style="color:#89DDFF;">,</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">to</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">params</span><span style="color:#89DDFF;">,</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">from</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">params</span><span style="color:#F07178;">)</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#82AAFF;">next</span><span style="color:#F07178;">()</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#89DDFF;">&lt;/</span><span style="color:#F07178;">script</span><span style="color:#89DDFF;">&gt;</span></span></code></pre></div></li></ol><p>无论使用哪种方式，都可以在组件中监听路由参数的变化并执行相应的逻辑。根据你的需求和代码结构，选择其中一种方式即可。</p><h2 id="_12-vue-的单项数据流的好处" tabindex="-1">12. Vue 的单项数据流的好处？ <a class="header-anchor" href="#_12-vue-的单项数据流的好处" aria-label="Permalink to &quot;12. Vue 的单项数据流的好处？&quot;">​</a></h2><p>Vue 单向数据流的几个好处：</p><ol><li><strong>可预测的数据流动：</strong> 在 Vue 中，数据是从父组件流向子组件的，这样的数据流动方向更加清晰和可控。子组件无法直接修改父组件的数据，只能通过 <code>props</code> 接收数据，这降低了数据修改的复杂性，有助于提高代码的可预测性和可维护性。</li><li><strong>追踪数据变化：</strong> 单向数据流使得数据的变化来源变得明确，当数据发生变化时，我们知道是哪个组件触发了变化。这使得在应用中追踪数据的变化变得更加容易，有助于快速定位和解决问题。</li><li><strong>可组合的组件：</strong> Vue 的组件可以更容易地进行组合和嵌套，因为每个组件都是相对独立的，通过 <code>props</code> 和自定义事件来传递和通信。这使得构建大型应用程序时，可以将复杂的 UI 拆分成可复用的组件，提高代码的可维护性和可测试性。</li><li><strong>更少的副作用：</strong> 单向数据流减少了副作用的可能性。由于数据流动是单向的，我们更容易追踪数据的修改和变化，减少了意外副作用的发生。</li><li><strong>更容易调试：</strong> 单向数据流使得应用中的数据流动更加可见和可预测。这对于调试和定位问题非常有帮助，因为你可以更容易地跟踪数据在组件之间的流动。</li></ol><h2 id="_13-vue在哪些生命周期里面可以直接访问到-dom" tabindex="-1">13. Vue在哪些生命周期里面可以直接访问到 dom? <a class="header-anchor" href="#_13-vue在哪些生命周期里面可以直接访问到-dom" aria-label="Permalink to &quot;13. Vue在哪些生命周期里面可以直接访问到 dom?&quot;">​</a></h2><p>在 Vue 的生命周期中，可以直接访问到 DOM 的阶段主要是在以下几个钩子函数中：</p><ol><li><p><strong><code>beforeMount</code>：</strong> 在实例挂载之前被调用，此时组件的模板已经编译完成，但尚未挂载到 DOM 上。在这个阶段，可以通过 <code>this.$el</code> 访问到组件的根 DOM 元素，但此时它还没有被添加到实际的页面 DOM 树中。</p></li><li><p><strong><code>mounted</code>：</strong> <strong>在实例挂载之后被调用，此时组件已经被添加到 DOM 树中。在这个阶段，可以通过 <code>this.$el</code> 访问到组件的根 DOM 元素，并且可以执行 DOM 操作、绑定事件等。</strong></p></li><li><p><strong><code>beforeUpdate</code>：</strong> 在数据更新之前被调用，此时组件尚未重新渲染。在这个阶段，可以访问到旧的 DOM 元素和数据，但新的数据尚未应用到组件上。</p></li><li><p><strong><code>updated</code>：</strong> 在数据更新之后被调用，此时组件已经重新渲染并更新到 DOM 树中。在这个阶段，可以访问到更新后的 DOM 元素和数据，进行一些额外的 DOM 操作。</p></li></ol><p>需要注意的是，在上述生命周期钩子函数中访问到的 DOM 元素是组件根元素，如果需要操作组件内部的其他 DOM 元素，可以结合使用 <code>ref</code> 来获取对应的 DOM 引用。</p><p>其他生命周期钩子函数如 <code>created</code> 和 <code>beforeDestroy</code> 等也可以访问到 DOM，但在这些阶段访问到的 DOM 可能还不完全稳定或部分已经被销毁，需要谨慎操作。</p><h3 id="vue2-和-vue3-两个版本可以直接访问到-dom-的阶段有什么区别吗" tabindex="-1">Vue2 和 Vue3 两个版本可以直接访问到 DOM 的阶段有什么区别吗 <a class="header-anchor" href="#vue2-和-vue3-两个版本可以直接访问到-dom-的阶段有什么区别吗" aria-label="Permalink to &quot;Vue2 和 Vue3 两个版本可以直接访问到 DOM 的阶段有什么区别吗&quot;">​</a></h3><p>在 Vue 2 和 Vue 3 的生命周期中，可以直接访问到 DOM 的阶段是基本一致的，但 Vue 3 引入了 Composition API，可能会影响部分生命周期钩子的使用方式。</p><p>以下是 Vue 2 和 Vue 3 中可以直接访问到 DOM 的生命周期钩子：</p><ol><li><p><strong><code>beforeMount</code>：</strong> 在实例挂载之前被调用，此时组件的模板已经编译完成，但尚未挂载到 DOM 上。</p></li><li><p><strong><code>mounted</code>：</strong> 在实例挂载之后被调用，此时组件已经被添加到 DOM 树中。在这个阶段，可以执行 DOM 操作、绑定事件等。</p></li><li><p><strong><code>beforeUpdate</code>：</strong> 在数据更新之前被调用，此时组件尚未重新渲染。在这个阶段，可以访问到旧的 DOM 元素和数据，但新的数据尚未应用到组件上。</p></li><li><p><strong><code>updated</code>：</strong> 在数据更新之后被调用，此时组件已经重新渲染并更新到 DOM 树中。在这个阶段，可以访问到更新后的 DOM 元素和数据，进行一些额外的 DOM 操作。</p></li><li><p><strong><code>beforeDestroy</code>：</strong> 在实例销毁之前被调用，此时组件尚未从 DOM 树中移除。</p></li><li><p><strong><code>destroyed</code>：</strong> 在实例销毁之后被调用，此时组件已经从 DOM 树中移除。在这个阶段可以执行一些清理操作。</p></li></ol><p>需要注意的是，在 Vue 3 中，由于 Composition API 的引入，组件内部可以使用 <code>ref</code> 和 <code>reactive</code> 等 API 来进行状态的管理，可能会影响到一些生命周期钩子的使用方式。例如，在 Vue 2 中，可以通过在 <code>mounted</code> 钩子中直接操作 DOM 元素，而在 Vue 3 中，你可能会倾向于使用 Composition API 的 <code>onMounted</code> 钩子来完成类似的操作。</p><p>总的来说，虽然在 Vue 3 中可能会有一些不同的使用模式，但可以直接访问 DOM 的生命周期阶段在两个版本中是基本相同的。</p><h2 id="_14-页面首次加载的时候-会触发哪些钩子函数" tabindex="-1">14. 页面首次加载的时候，会触发哪些钩子函数？ <a class="header-anchor" href="#_14-页面首次加载的时候-会触发哪些钩子函数" aria-label="Permalink to &quot;14. 页面首次加载的时候，会触发哪些钩子函数？&quot;">​</a></h2><p>在 Vue.js 中，页面首次加载时会依次触发以下生命周期钩子函数：</p><ol><li><p><strong><code>beforeCreate</code>：</strong> 组件实例刚在内存中创建，尚未初始化。在这个阶段，组件的数据和事件初始化都尚未开始。</p></li><li><p><strong><code>created</code>：</strong> 组件实例已经完全创建，包括数据初始化、事件监听等。但是此时组件尚未挂载到 DOM 上。</p></li><li><p><strong><code>beforeMount</code>：</strong> 在实例挂载之前被调用，此时组件的模板已经编译完成，但尚未挂载到 DOM 上。</p></li><li><p><strong><code>mounted</code>：</strong> 在实例挂载之后被调用，此时组件已经被添加到 DOM 树中。在这个阶段，可以执行 DOM 操作、绑定事件等。</p></li></ol><p>这些钩子函数会在组件实例化、初始化数据、模板编译和挂载等阶段依次被调用，从而完成页面的首次加载过程。</p><h2 id="_15-vue-模版样式-scoped-的作用和用法" tabindex="-1">15. Vue 模版样式 scoped 的作用和用法 <a class="header-anchor" href="#_15-vue-模版样式-scoped-的作用和用法" aria-label="Permalink to &quot;15. Vue 模版样式 scoped 的作用和用法&quot;">​</a></h2><p><code>scoped</code> 是 Vue 模板的一个特殊属性，用于给组件的样式添加作用域，以避免样式冲突和污染全局作用域。当在 Vue 组件的 <code>&lt;style&gt;</code> 标签中加入 <code>scoped</code> 属性时，该样式仅会应用于当前组件的元素，不会影响其他组件或全局样式。</p><p>使用 <code>scoped</code> 属性的样式将会被自动编译成类似以下的格式：</p><div class="language-css"><button title="Copy Code" class="copy"></button><span class="lang">css</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#A6ACCD;">&lt;</span><span style="color:#FFCB6B;">style</span><span style="color:#A6ACCD;"> scoped</span><span style="color:#89DDFF;">&gt;</span></span>
<span class="line"><span style="color:#A6ACCD;">  </span><span style="color:#89DDFF;">.</span><span style="color:#FFCB6B;">example</span><span style="color:#89DDFF;">[</span><span style="color:#C792EA;">data-v-f3f3eg9</span><span style="color:#89DDFF;">]</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#B2CCD6;">color</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> red</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#A6ACCD;">  </span><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#A6ACCD;">&lt;/</span><span style="color:#FFCB6B;">style</span><span style="color:#89DDFF;">&gt;</span></span></code></pre></div><p>在具体的 HTML 元素上，会自动添加一个唯一的 <code>data-v-*</code> 特性，以确保样式只作用于该组件内部的元素。</p><p>例如，如果有以下组件模板：</p><div class="language-vue"><button title="Copy Code" class="copy"></button><span class="lang">vue</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#89DDFF;">&lt;</span><span style="color:#F07178;">template</span><span style="color:#89DDFF;">&gt;</span></span>
<span class="line"><span style="color:#A6ACCD;">  </span><span style="color:#89DDFF;">&lt;</span><span style="color:#F07178;">div</span><span style="color:#89DDFF;"> </span><span style="color:#C792EA;">class</span><span style="color:#89DDFF;">=</span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">example</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">&gt;</span><span style="color:#A6ACCD;">This is a scoped example.</span><span style="color:#89DDFF;">&lt;/</span><span style="color:#F07178;">div</span><span style="color:#89DDFF;">&gt;</span></span>
<span class="line"><span style="color:#89DDFF;">&lt;/</span><span style="color:#F07178;">template</span><span style="color:#89DDFF;">&gt;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#89DDFF;">&lt;</span><span style="color:#F07178;">style</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">scoped</span><span style="color:#89DDFF;">&gt;</span></span>
<span class="line"><span style="color:#89DDFF;">.</span><span style="color:#FFCB6B;">example</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#A6ACCD;">  </span><span style="color:#B2CCD6;">color</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> red</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#89DDFF;">&lt;/</span><span style="color:#F07178;">style</span><span style="color:#89DDFF;">&gt;</span></span></code></pre></div><p>那么在渲染后的 HTML 中，会变成类似这样：</p><div class="language-html"><button title="Copy Code" class="copy"></button><span class="lang">html</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#89DDFF;">&lt;</span><span style="color:#F07178;">div</span><span style="color:#89DDFF;"> </span><span style="color:#C792EA;">class</span><span style="color:#89DDFF;">=</span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">example</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;"> </span><span style="color:#C792EA;">data-v-f3f3eg9</span><span style="color:#89DDFF;">&gt;</span><span style="color:#A6ACCD;">This is a scoped example.</span><span style="color:#89DDFF;">&lt;/</span><span style="color:#F07178;">div</span><span style="color:#89DDFF;">&gt;</span></span></code></pre></div><p>这样做的好处是：</p><ol><li><strong>避免样式冲突：</strong> 每个组件的样式都会被限制在各自的作用域内，不会影响其他组件。</li><li><strong>模块化开发：</strong> 组件的样式与其模板和逻辑一起被封装在一起，更符合模块化开发的思想。</li><li><strong>可维护性：</strong> 易于理解和维护，不用担心全局样式的副作用。</li></ol><p>需要注意的是，<code>scoped</code> 样式只对组件的根元素及其子元素生效，不包括子组件的根元素。如果要为子组件的根元素应用样式，需要在子组件的 <code>&lt;style&gt;</code> 中再次使用 <code>scoped</code> 属性。</p><div class="language-vue"><button title="Copy Code" class="copy"></button><span class="lang">vue</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#89DDFF;">&lt;</span><span style="color:#F07178;">template</span><span style="color:#89DDFF;">&gt;</span></span>
<span class="line"><span style="color:#A6ACCD;">  </span><span style="color:#89DDFF;">&lt;</span><span style="color:#F07178;">div</span><span style="color:#89DDFF;">&gt;</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#89DDFF;">&lt;</span><span style="color:#F07178;">child-component</span><span style="color:#89DDFF;">&gt;&lt;/</span><span style="color:#F07178;">child-component</span><span style="color:#89DDFF;">&gt;</span></span>
<span class="line"><span style="color:#A6ACCD;">  </span><span style="color:#89DDFF;">&lt;/</span><span style="color:#F07178;">div</span><span style="color:#89DDFF;">&gt;</span></span>
<span class="line"><span style="color:#89DDFF;">&lt;/</span><span style="color:#F07178;">template</span><span style="color:#89DDFF;">&gt;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#89DDFF;">&lt;</span><span style="color:#F07178;">style</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">scoped</span><span style="color:#89DDFF;">&gt;</span></span>
<span class="line"><span style="color:#676E95;font-style:italic;">/* 这里的样式只对当前组件内的元素生效 */</span></span>
<span class="line"><span style="color:#89DDFF;">&lt;/</span><span style="color:#F07178;">style</span><span style="color:#89DDFF;">&gt;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#89DDFF;">&lt;</span><span style="color:#F07178;">child-component</span><span style="color:#89DDFF;">&gt;</span></span>
<span class="line"><span style="color:#A6ACCD;">  &lt;!-- 这里的样式需要在子组件的 &lt;style&gt; 标签中再次使用 scoped 属性 --&gt;</span></span>
<span class="line"><span style="color:#89DDFF;">&lt;/</span><span style="color:#F07178;">child-component</span><span style="color:#89DDFF;">&gt;</span></span></code></pre></div><p>总之，<code>scoped</code> 属性是 Vue 中用于实现组件作用域样式的重要特性，可以有效地管理和隔离组件的样式。</p><h4 id="样式穿透的写法" tabindex="-1">样式穿透的写法 <a class="header-anchor" href="#样式穿透的写法" aria-label="Permalink to &quot;样式穿透的写法&quot;">​</a></h4><p>在 Vue 中，如果你需要在一个组件的样式中修改或覆盖子组件的样式（即穿透子组件的样式作用域），你可以使用 <code>&gt;&gt;&gt;</code> 或 <code>/deep/</code> 或 <code>::v-deep</code>（Vue 3）选择器来实现。这些选择器会帮助你突破样式的作用域限制，直接影响到子组件的样式。</p><p>以下是使用这些选择器的示例：</p><p>假设你有一个父组件，其中包含了一个子组件 <code>&lt;child-component&gt;</code>，而你希望修改子组件内元素的样式。</p><p><strong>Vue 2 使用 <code>&gt;&gt;&gt;</code> 或 <code>/deep/</code>：</strong></p><div class="language-vue"><button title="Copy Code" class="copy"></button><span class="lang">vue</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#89DDFF;">&lt;</span><span style="color:#F07178;">template</span><span style="color:#89DDFF;">&gt;</span></span>
<span class="line"><span style="color:#A6ACCD;">  </span><span style="color:#89DDFF;">&lt;</span><span style="color:#F07178;">div</span><span style="color:#89DDFF;">&gt;</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#89DDFF;">&lt;</span><span style="color:#F07178;">child-component</span><span style="color:#89DDFF;">&gt;&lt;/</span><span style="color:#F07178;">child-component</span><span style="color:#89DDFF;">&gt;</span></span>
<span class="line"><span style="color:#A6ACCD;">  </span><span style="color:#89DDFF;">&lt;/</span><span style="color:#F07178;">div</span><span style="color:#89DDFF;">&gt;</span></span>
<span class="line"><span style="color:#89DDFF;">&lt;/</span><span style="color:#F07178;">template</span><span style="color:#89DDFF;">&gt;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#89DDFF;">&lt;</span><span style="color:#F07178;">style</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">scoped</span><span style="color:#89DDFF;">&gt;</span></span>
<span class="line"><span style="color:#676E95;font-style:italic;">/* 使用 &gt;&gt;&gt; 或 /deep/ 来穿透子组件的样式作用域 */</span></span>
<span class="line"><span style="color:#89DDFF;">.</span><span style="color:#FFCB6B;">parent-container</span><span style="color:#A6ACCD;"> &gt;&gt;&gt; </span><span style="color:#89DDFF;">.</span><span style="color:#FFCB6B;">child-element</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#A6ACCD;">  </span><span style="color:#676E95;font-style:italic;">/* 在这里添加样式 */</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#89DDFF;">&lt;/</span><span style="color:#F07178;">style</span><span style="color:#89DDFF;">&gt;</span></span></code></pre></div><p><strong>Vue 3 使用 <code>::v-deep</code>：</strong></p><div class="language-vue"><button title="Copy Code" class="copy"></button><span class="lang">vue</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#89DDFF;">&lt;</span><span style="color:#F07178;">template</span><span style="color:#89DDFF;">&gt;</span></span>
<span class="line"><span style="color:#A6ACCD;">  </span><span style="color:#89DDFF;">&lt;</span><span style="color:#F07178;">div</span><span style="color:#89DDFF;">&gt;</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#89DDFF;">&lt;</span><span style="color:#F07178;">child-component</span><span style="color:#89DDFF;">&gt;&lt;/</span><span style="color:#F07178;">child-component</span><span style="color:#89DDFF;">&gt;</span></span>
<span class="line"><span style="color:#A6ACCD;">  </span><span style="color:#89DDFF;">&lt;/</span><span style="color:#F07178;">div</span><span style="color:#89DDFF;">&gt;</span></span>
<span class="line"><span style="color:#89DDFF;">&lt;/</span><span style="color:#F07178;">template</span><span style="color:#89DDFF;">&gt;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#89DDFF;">&lt;</span><span style="color:#F07178;">style</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">scoped</span><span style="color:#89DDFF;">&gt;</span></span>
<span class="line"><span style="color:#676E95;font-style:italic;">/* 使用 ::v-deep 来穿透子组件的样式作用域 */</span></span>
<span class="line"><span style="color:#89DDFF;">.</span><span style="color:#FFCB6B;">parent-container</span><span style="color:#A6ACCD;"> ::</span><span style="color:#FFCB6B;">v-deep</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">.</span><span style="color:#FFCB6B;">child-element</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#A6ACCD;">  </span><span style="color:#676E95;font-style:italic;">/* 在这里添加样式 */</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#89DDFF;">&lt;/</span><span style="color:#F07178;">style</span><span style="color:#89DDFF;">&gt;</span></span></code></pre></div><p>在这些示例中，<code>.parent-container</code> 是父组件的选择器，<code>.child-element</code> 是子组件内部元素的选择器。通过使用这些特殊选择器，你可以覆盖子组件的样式，即使子组件的样式是在其内部使用了 <code>scoped</code> 属性进行限制的。</p><p>需要注意的是，虽然这些选择器可以实现样式的穿透，但过度使用样式穿透可能会导致样式的混乱和不易维护。在大多数情况下，建议通过适当的组件设计和样式约定来避免过多使用样式穿透。</p><h2 id="_16-vue-自带的动画效果" tabindex="-1">16. Vue 自带的动画效果 <a class="header-anchor" href="#_16-vue-自带的动画效果" aria-label="Permalink to &quot;16. Vue 自带的动画效果&quot;">​</a></h2><p>Vue 自带的动画效果是通过 Vue 的过渡系统实现的。过渡系统可以让你在元素进入或离开 DOM 时自动应用动画效果，以及在一些情况下通过触发 CSS 类来实现动画。</p><p>以下是实现 Vue 自带的动画效果的一般步骤：</p><ol><li><p><strong>使用 <code>&lt;transition&gt;</code> 或 <code>&lt;transition-group&gt;</code> 组件包裹需要动画的元素。</strong></p><ul><li><code>&lt;transition&gt;</code> 用于单个元素的过渡动画。</li><li><code>&lt;transition-group&gt;</code> 用于列表或多个元素的过渡动画。</li></ul></li><li><p><strong>为过渡组件设置属性和事件。</strong></p><ul><li><code>name</code> 属性定义过渡的名称，用于自动生成过渡类名，默认为 <code>&quot;v&quot;</code>。</li><li><code>appear</code> 属性用于设置元素初始渲染时是否执行过渡，默认为 <code>false</code>。</li><li><code>mode</code> 属性用于设置过渡模式，可以是 <code>&quot;in-out&quot;</code>（新元素先进入，旧元素再离开）或 <code>&quot;out-in&quot;</code>（旧元素先离开，新元素再进入），默认为 <code>&quot;out-in&quot;</code>。</li><li><code>type</code> 属性用于设置过渡类型，可以是 <code>&quot;transition&quot;</code>（CSS 过渡）或 <code>&quot;animation&quot;</code>（CSS 动画），默认为 <code>&quot;transition&quot;</code>。</li></ul></li><li><p><strong>使用钩子函数或 CSS 类来定义动画效果。</strong></p><ul><li><code>before-enter</code>、<code>enter</code>、<code>after-enter</code>、<code>enter-cancelled</code> 钩子函数用于定义元素进入时的动画。</li><li><code>before-leave</code>、<code>leave</code>、<code>after-leave</code>、<code>leave-cancelled</code> 钩子函数用于定义元素离开时的动画。</li></ul></li></ol><p>以下是一个简单的例子，演示了如何在 Vue 中使用过渡来实现动画效果：</p><div class="language-vue"><button title="Copy Code" class="copy"></button><span class="lang">vue</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#89DDFF;">&lt;</span><span style="color:#F07178;">template</span><span style="color:#89DDFF;">&gt;</span></span>
<span class="line"><span style="color:#A6ACCD;">  </span><span style="color:#89DDFF;">&lt;</span><span style="color:#F07178;">div</span><span style="color:#89DDFF;">&gt;</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#89DDFF;">&lt;</span><span style="color:#F07178;">button</span><span style="color:#89DDFF;"> </span><span style="color:#C792EA;">@click</span><span style="color:#89DDFF;">=</span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">show = !show</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">&gt;</span><span style="color:#A6ACCD;">Toggle</span><span style="color:#89DDFF;">&lt;/</span><span style="color:#F07178;">button</span><span style="color:#89DDFF;">&gt;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#89DDFF;">&lt;</span><span style="color:#F07178;">transition</span><span style="color:#89DDFF;"> </span><span style="color:#C792EA;">name</span><span style="color:#89DDFF;">=</span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">fade</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;"> </span><span style="color:#C792EA;">mode</span><span style="color:#89DDFF;">=</span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">out-in</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">&gt;</span></span>
<span class="line"><span style="color:#A6ACCD;">      </span><span style="color:#89DDFF;">&lt;</span><span style="color:#F07178;">p</span><span style="color:#89DDFF;"> </span><span style="color:#C792EA;">v-if</span><span style="color:#89DDFF;">=</span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">show</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;"> </span><span style="color:#C792EA;">key</span><span style="color:#89DDFF;">=</span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">text</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">&gt;</span><span style="color:#A6ACCD;">Hello, Vue Transition!</span><span style="color:#89DDFF;">&lt;/</span><span style="color:#F07178;">p</span><span style="color:#89DDFF;">&gt;</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#89DDFF;">&lt;/</span><span style="color:#F07178;">transition</span><span style="color:#89DDFF;">&gt;</span></span>
<span class="line"><span style="color:#A6ACCD;">  </span><span style="color:#89DDFF;">&lt;/</span><span style="color:#F07178;">div</span><span style="color:#89DDFF;">&gt;</span></span>
<span class="line"><span style="color:#89DDFF;">&lt;/</span><span style="color:#F07178;">template</span><span style="color:#89DDFF;">&gt;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#89DDFF;">&lt;</span><span style="color:#F07178;">script</span><span style="color:#89DDFF;">&gt;</span></span>
<span class="line"><span style="color:#89DDFF;font-style:italic;">export</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;font-style:italic;">default</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#A6ACCD;">  </span><span style="color:#F07178;">data</span><span style="color:#89DDFF;">()</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#89DDFF;font-style:italic;">return</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">      show</span><span style="color:#89DDFF;">:</span><span style="color:#F07178;"> </span><span style="color:#FF9CAC;">false</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#89DDFF;">};</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#89DDFF;">};</span></span>
<span class="line"><span style="color:#89DDFF;">&lt;/</span><span style="color:#F07178;">script</span><span style="color:#89DDFF;">&gt;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#89DDFF;">&lt;</span><span style="color:#F07178;">style</span><span style="color:#89DDFF;">&gt;</span></span>
<span class="line"><span style="color:#676E95;font-style:italic;">/* 定义过渡效果 */</span></span>
<span class="line"><span style="color:#89DDFF;">.</span><span style="color:#FFCB6B;">fade-enter-active</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">.</span><span style="color:#FFCB6B;">fade-leave-active</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#A6ACCD;">  </span><span style="color:#B2CCD6;">transition</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> opacity </span><span style="color:#F78C6C;">0.5s</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#89DDFF;">.</span><span style="color:#FFCB6B;">fade-enter</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">.</span><span style="color:#FFCB6B;">fade-leave-to</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#A6ACCD;">  </span><span style="color:#B2CCD6;">opacity</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#F78C6C;">0</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#89DDFF;">&lt;/</span><span style="color:#F07178;">style</span><span style="color:#89DDFF;">&gt;</span></span></code></pre></div><p>在这个例子中，当点击按钮时，<code>&lt;p&gt;</code> 元素将以淡入淡出的动画效果显示或隐藏。</p><p>需要注意的是，Vue 过渡系统默认使用 CSS 过渡和动画来实现动画效果，但你也可以通过 JavaScript 钩子函数来自定义动画效果。详细的文档和示例可以在 Vue 官方文档中找到：<a href="https://vuejs.org/v2/guide/transitions.html" target="_blank" rel="noreferrer">Vue 过渡 &amp; 动画</a>。</p><h2 id="🍓扩展问题" tabindex="-1">🍓扩展问题 <a class="header-anchor" href="#🍓扩展问题" aria-label="Permalink to &quot;🍓扩展问题&quot;">​</a></h2><h3 id="简单说一下平时为了提升开发效率封装过哪些组件" tabindex="-1">简单说一下平时为了提升开发效率封装过哪些组件？ <a class="header-anchor" href="#简单说一下平时为了提升开发效率封装过哪些组件" aria-label="Permalink to &quot;简单说一下平时为了提升开发效率封装过哪些组件？&quot;">​</a></h3><h3 id="" tabindex="-1"><a class="header-anchor" href="#" aria-label="Permalink to &quot;&quot;">​</a></h3><h3 id="接口没出来的时候-做过-mock-吗-常见的-mock-语法。" tabindex="-1">接口没出来的时候，做过 mock 吗， 常见的 mock 语法。 <a class="header-anchor" href="#接口没出来的时候-做过-mock-吗-常见的-mock-语法。" aria-label="Permalink to &quot;接口没出来的时候，做过 mock 吗， 常见的 mock 语法。&quot;">​</a></h3><h3 id="data-属性和-methods-方法可以同名吗" tabindex="-1">data 属性和 methods 方法可以同名吗 <a class="header-anchor" href="#data-属性和-methods-方法可以同名吗" aria-label="Permalink to &quot;data 属性和 methods 方法可以同名吗&quot;">​</a></h3><p>可以，methods 的方法名会被 data 的属性覆盖</p></div></div></main><footer class="VPDocFooter" data-v-c4b0d3cf data-v-face870a><!--[--><!--]--><!----><div class="prev-next" data-v-face870a><div class="pager" data-v-face870a><a class="pager-link prev" href="/erhang-records/browser/l2.html" data-v-face870a><span class="desc" data-v-face870a>Previous page</span><span class="title" data-v-face870a>渲染优化</span></a></div><div class="has-prev pager" data-v-face870a><a class="pager-link next" href="/erhang-records/framework/vue-router.html" data-v-face870a><span class="desc" data-v-face870a>Next page</span><span class="title" data-v-face870a>Vue-Router</span></a></div></div></footer><!--[--><!--]--></div></div></div><!--[--><!--]--></div></div><!----><!--[--><!--]--></div></div>
    <script>__VP_HASH_MAP__ = JSON.parse("{\"api-examples.md\":\"d50d33f2\",\"browser_l1.md\":\"3a2a462e\",\"javascript_l1.md\":\"4baef55c\",\"browser_l2.md\":\"ea1298c2\",\"framework_vue-life.md\":\"09a278ca\",\"framework_vue-router.md\":\"c5f8da0a\",\"framework_vuex.md\":\"f9037395\",\"index.md\":\"25a95e60\",\"markdown-examples.md\":\"77c49ec2\",\"nodejs_basic_lesson1.md\":\"16ddc410\",\"nodejs_basic_lesson2.md\":\"a42c8909\",\"nodejs_other_lesson1.md\":\"4f0d6e1e\",\"framework_react.md\":\"5fc0f469\",\"framework_redux.md\":\"50a46721\",\"framework_vite-webpack.md\":\"cc6bdc4a\",\"framework_koa.md\":\"ca5c726e\",\"framework_vue3source.md\":\"fbe62d34\",\"framework_vue.md\":\"f502b4df\",\"framework_react-router.md\":\"853f5ffb\",\"framework_vue2source.md\":\"669c10a6\",\"framework_vue-component.md\":\"9ce28844\",\"study-react.md\":\"ab376bc1\"}")
__VP_SITE_DATA__ = JSON.parse("{\"lang\":\"en-US\",\"dir\":\"ltr\",\"title\":\"ErHang Records\",\"description\":\"A VitePress Site\",\"base\":\"/erhang-records/\",\"head\":[],\"appearance\":true,\"themeConfig\":{\"nav\":[{\"text\":\"Home\",\"link\":\"/\"},{\"text\":\"Records\",\"link\":\"/JavaScript/l1\"}],\"outline\":\"deep\",\"sidebar\":[{\"text\":\"Examples\",\"items\":[{\"text\":\"Markdown Examples\",\"link\":\"/markdown-examples\"},{\"text\":\"Runtime API Examples\",\"link\":\"/api-examples\"},{\"text\":\"React Template\",\"link\":\"/study-react\"}]},{\"text\":\"Interview-related\",\"items\":[{\"text\":\"基础篇\",\"items\":[{\"text\":\"模块化\",\"link\":\"/JavaScript/l1\"}]},{\"text\":\"浏览器相关知识\",\"items\":[{\"text\":\"渲染流程\",\"link\":\"/browser/l1\"},{\"text\":\"渲染优化\",\"link\":\"/browser/l2\"}]},{\"text\":\"框架篇\",\"items\":[{\"text\":\"Vue\",\"link\":\"/framework/vue\"},{\"text\":\"Vue-Router\",\"link\":\"/framework/vue-router\"},{\"text\":\"Vuex\",\"link\":\"/framework/vuex\"},{\"text\":\"Vue 组件通信\",\"link\":\"/framework/vue-component\"},{\"text\":\"Vue 生命周期\",\"link\":\"/framework/vue-life\"},{\"text\":\"Vue2 源码\",\"link\":\"/framework/vue2Source\"},{\"text\":\"Vue3 源码\",\"link\":\"/framework/vue3Source\"},{\"text\":\"React\",\"link\":\"/framework/react\"},{\"text\":\"React-Router\",\"link\":\"/framework/react-router\"},{\"text\":\"Redux\",\"link\":\"/framework/redux\"},{\"text\":\"Koa\",\"link\":\"/framework/koa\"},{\"text\":\"Vite Webpack\",\"link\":\"/framework/vite-webpack\"}]}]},{\"text\":\"Node-Learn\",\"items\":[{\"text\":\"NodeJs基础\",\"items\":[{\"text\":\"第一课\",\"link\":\"/nodejs/basic/lesson1\"}]},{\"text\":\"NodeJs进阶\",\"items\":[{\"text\":\"第一课\",\"link\":\"/nodejs/other/lesson1\"}]}]}],\"socialLinks\":[{\"icon\":\"github\",\"link\":\"https://github.com/vuejs/vitepress\"}]},\"locales\":{},\"scrollOffset\":90,\"cleanUrls\":false}")</script>
    
  </body>
</html>